{"version":3,"mappings":"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","names":["_createMatcher","table","path","_matchRoutes","_createTableFromExport","matcherExport","property","key","value","createMatcherFromExport","matches","_sortRoutesMap","subPath","staticMatch","m","a","b","suspectProtoRx","suspectConstructorRx","JsonSigRx","jsonParseTransform","warnKeyDropped","destr","options","_value","_lval","error","_defu","baseObject","defaults","namespace","merger","_isPlainObject","object","prototype","createDefu","arguments_","p","c","defu","defuFn","currentValue","hasProp","obj","prop","__defProp$1","__defNormalProp$1","__publicField$1","H3Error","message","opts","sanitizeStatusCode","sanitizeStatusMessage","createError","input","isError","err","originalMessage","_a","DISALLOWED_STATUS_CHARS","statusMessage","statusCode","defaultStatusCode","NUXT_ERROR_SIGNATURE","useError","toRef","useNuxtApp","showError","nuxtError","nuxtApp","error2","clearError","useRouter","isNuxtError","createH3Error","appLayoutTransition","appPageTransition","appKeepalive","vueAppRootContainer","UNDEFINED","HOLE","NAN","POSITIVE_INFINITY","NEGATIVE_INFINITY","NEGATIVE_ZERO","parse","serialized","revivers","unflatten","parsed","hydrate","values","hydrated","index","standalone","type","reviver","set","i","map","array","n","inlineConfig","__appConfig","useAppConfig","reactive","manifest","matcher","fetchManifest","buildId","buildAssetsURL","getAppManifest","getRouteRules","url","loadPayload","payloadURL","_getPayloadURL","cache","isPrerendered","prerendered","_importPayload","payload","extension","u","hasProtocol","hash","joinURL","useRuntimeConfig","payloadPromise","res","parsePayload","useRoute","withoutTrailingSlash","rules","payloadCache","getNuxtClientPayload","el","inlineData","externalData","definePayloadReviver","name","revive","reloadNuxtApp","handledPath","FetchError","createFetchError","ctx","errorMessage","_b","method","_c","_d","_e","requestStr","statusStr","fetchError","refKey","payloadMethods","isPayloadMethod","isJSONSerializable","textTypes","JSON_RE","detectResponseType","_contentType","contentType","mergeFetchOptions","Headers","merged","retryStatusCodes","nullBodyResponses","createFetch","globalOptions","fetch","AbortController","onError","context","isAbort","retries","responseCode","retryDelay","resolve","$fetchRaw","_request","_options","withBase","withQuery","controller","responseType","data","parseFunction","$fetch","request","args","defaultOptions","_globalThis","ofetch","baseURL","shallowRef","ref","shallowReactive","revive_payload_client_4sVQNw7RlN","defineNuxtPlugin","__temp","__restore","__executeAsync","globalWindow","logger","storybook_LiuGAqG6Vu","nuxtMainApp","getContext","applyNuxtPlugins","vueApp","storyContext","nuxt","createNuxtApp","router","createRouter","createWebHistory","plugin","plugins","unheadPlugins","unhead_KgADcZ0jPj","head","createClientHead","setHeadInjectionHandler","pauseDOMUpdates","syncHead","renderDOMHead","interpolatePath","route","match","r","generateRouteKey","routeProps","override","matchedRoute","source","wrapInKeepAlive","props","children","h","KeepAlive","toArray","_routes","_wrapIf","component","slots","isChangingPage","to","from","comp","routerOptions0","savedPosition","behavior","position","routeAllowsScrollToTop","_getHashElementScrollMarginTop","hasTransition","defaultPageTransition","hookToWait","nextTick","selector","elem","configRouterOptions","routerOptions","validate","defineNuxtRouteMiddleware","unsub","final","unsub2","manifest_45route_45rule","globalMiddleware","namedMiddleware","createCurrentLocation","location","renderedPath","pathname","search","hashPos","base","slicePos","pathFromHash","withoutBase","displayedPath","isEqual","routerBase","history","createWebHashHistory","startPosition","initialURL","START_LOCATION","routes","previousRoute","_to","_route","syncCurrentRoute","initialLayout","isReadonly","componentMiddleware","entry","middlewareEntries","middleware","result","_from","failure","payload_client_yVLowv6hDl","onNuxtReady","parseURL","check_outdated_build_client_8vK7RkfGxZ","timeout","getLatestManifest","currentManifest","meta","components_plugin_KR1HBZs4kY","layouts","__vitePreload","prefetch_client_5tzzN0oIVL","layout","chunk_reload_client_UciE0i6zes","config","chunkErrors","reloadAppAtPath","router_jmwsqit4Rs","RouteProvider","defineComponent","previousKey","provide","PageRouteSymbol","__nuxt_component_0","attrs","expose","pageRef","forkRoute","inject","_layoutMeta","LayoutMetaSymbol","vnode","done","watch","next","prev","RouterView","isRenderingNewRouteInOldFork","haveParentRoutesRendered","hasSameChildren","transitionProps","_mergeTransitionProps","keepaliveConfig","defaultKeepaliveConfig","Transition","Suspense","providerVNode","_props","fork","newRoute","Component","LayoutLoader","LayoutComponent","__nuxt_component_1","injectedRoute","useVueRouterRoute","computed","layout2","unref","layoutRef","hasLayout","defaultLayoutTransition","LayoutProvider","mergeProps","_error","__props","line","is404","description","stack","_Error404","defineAsyncComponent","_Error","ErrorTemplate","IslandRenderer","onResolve","SingleRenderer","hooks","hook","onErrorCaptured","target","info","hookError","onServerPrefetch","islandContext","vueAppPromise","createSSRApp","RootComponent","createApp","handleVueError","applyPlugins","entry$1","ssrContext"],"sources":["../../node_modules/radix3/dist/index.mjs","../../node_modules/destr/dist/index.mjs","../../node_modules/defu/dist/defu.mjs","../../node_modules/h3/dist/index.mjs","../../node_modules/nuxt/dist/app/composables/error.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/nuxt.config.mjs","../../node_modules/devalue/src/constants.js","../../node_modules/devalue/src/parse.js","../../.nuxt/app.config.mjs","../../node_modules/nuxt/dist/app/config.js","../../node_modules/nuxt/dist/app/composables/manifest.js","../../node_modules/nuxt/dist/app/composables/payload.js","../../node_modules/nuxt/dist/app/composables/chunk.js","../../node_modules/ofetch/dist/shared/ofetch.00501375.mjs","../../node_modules/ofetch/dist/index.mjs","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/fetch.mjs","../../node_modules/nuxt/dist/app/plugins/revive-payload.client.js","../../node_modules/@storybook-vue/nuxt/dist/runtime/plugins/storybook.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/unhead-plugins.mjs","../../node_modules/nuxt/dist/head/runtime/plugins/unhead.js","../../node_modules/nuxt/dist/pages/runtime/utils.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/routes.mjs","../../node_modules/nuxt/dist/app/components/utils.js","../../node_modules/nuxt/dist/pages/runtime/router.options.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/router.options.mjs","../../node_modules/nuxt/dist/pages/runtime/validate.js","../../node_modules/nuxt/dist/app/middleware/manifest-route-rule.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/middleware.mjs","../../node_modules/nuxt/dist/pages/runtime/plugins/router.js","../../node_modules/nuxt/dist/app/plugins/payload.client.js","../../node_modules/nuxt/dist/app/plugins/check-outdated-build.client.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/components.plugin.mjs","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/layouts.mjs","../../node_modules/nuxt/dist/pages/runtime/plugins/prefetch.client.js","../../node_modules/nuxt/dist/app/plugins/chunk-reload.client.js","../../virtual:nuxt:/mnt/data/web_projects/nuxt3-project/.nuxt/plugins/client.mjs","../../node_modules/nuxt/dist/app/components/route-provider.js","../../node_modules/nuxt/dist/pages/runtime/page.js","../../node_modules/nuxt/dist/app/components/nuxt-layout.js","../../node_modules/nuxt/dist/app/components/nuxt-error-page.vue","../../node_modules/nuxt/dist/app/components/nuxt-root.vue","../../node_modules/nuxt/dist/app/entry.js"],"sourcesContent":["const NODE_TYPES = {\n  NORMAL: 0,\n  WILDCARD: 1,\n  PLACEHOLDER: 2\n};\n\nfunction createRouter(options = {}) {\n  const ctx = {\n    options,\n    rootNode: createRadixNode(),\n    staticRoutesMap: {}\n  };\n  const normalizeTrailingSlash = (p) => options.strictTrailingSlash ? p : p.replace(/\\/$/, \"\") || \"/\";\n  if (options.routes) {\n    for (const path in options.routes) {\n      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);\n    }\n  }\n  return {\n    ctx,\n    // @ts-ignore\n    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),\n    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),\n    remove: (path) => remove(ctx, normalizeTrailingSlash(path))\n  };\n}\nfunction lookup(ctx, path) {\n  const staticPathNode = ctx.staticRoutesMap[path];\n  if (staticPathNode) {\n    return staticPathNode.data;\n  }\n  const sections = path.split(\"/\");\n  const params = {};\n  let paramsFound = false;\n  let wildcardNode = null;\n  let node = ctx.rootNode;\n  let wildCardParam = null;\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i];\n    if (node.wildcardChildNode !== null) {\n      wildcardNode = node.wildcardChildNode;\n      wildCardParam = sections.slice(i).join(\"/\");\n    }\n    const nextNode = node.children.get(section);\n    if (nextNode !== void 0) {\n      node = nextNode;\n    } else {\n      node = node.placeholderChildNode;\n      if (node !== null) {\n        params[node.paramName] = section;\n        paramsFound = true;\n      } else {\n        break;\n      }\n    }\n  }\n  if ((node === null || node.data === null) && wildcardNode !== null) {\n    node = wildcardNode;\n    params[node.paramName || \"_\"] = wildCardParam;\n    paramsFound = true;\n  }\n  if (!node) {\n    return null;\n  }\n  if (paramsFound) {\n    return {\n      ...node.data,\n      params: paramsFound ? params : void 0\n    };\n  }\n  return node.data;\n}\nfunction insert(ctx, path, data) {\n  let isStaticRoute = true;\n  const sections = path.split(\"/\");\n  let node = ctx.rootNode;\n  let _unnamedPlaceholderCtr = 0;\n  for (const section of sections) {\n    let childNode;\n    if (childNode = node.children.get(section)) {\n      node = childNode;\n    } else {\n      const type = getNodeType(section);\n      childNode = createRadixNode({ type, parent: node });\n      node.children.set(section, childNode);\n      if (type === NODE_TYPES.PLACEHOLDER) {\n        childNode.paramName = section === \"*\" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);\n        node.placeholderChildNode = childNode;\n        isStaticRoute = false;\n      } else if (type === NODE_TYPES.WILDCARD) {\n        node.wildcardChildNode = childNode;\n        childNode.paramName = section.slice(\n          3\n          /* \"**:\" */\n        ) || \"_\";\n        isStaticRoute = false;\n      }\n      node = childNode;\n    }\n  }\n  node.data = data;\n  if (isStaticRoute === true) {\n    ctx.staticRoutesMap[path] = node;\n  }\n  return node;\n}\nfunction remove(ctx, path) {\n  let success = false;\n  const sections = path.split(\"/\");\n  let node = ctx.rootNode;\n  for (const section of sections) {\n    node = node.children.get(section);\n    if (!node) {\n      return success;\n    }\n  }\n  if (node.data) {\n    const lastSection = sections[sections.length - 1];\n    node.data = null;\n    if (Object.keys(node.children).length === 0) {\n      const parentNode = node.parent;\n      parentNode.children.delete(lastSection);\n      parentNode.wildcardChildNode = null;\n      parentNode.placeholderChildNode = null;\n    }\n    success = true;\n  }\n  return success;\n}\nfunction createRadixNode(options = {}) {\n  return {\n    type: options.type || NODE_TYPES.NORMAL,\n    parent: options.parent || null,\n    children: /* @__PURE__ */ new Map(),\n    data: options.data || null,\n    paramName: options.paramName || null,\n    wildcardChildNode: null,\n    placeholderChildNode: null\n  };\n}\nfunction getNodeType(str) {\n  if (str.startsWith(\"**\")) {\n    return NODE_TYPES.WILDCARD;\n  }\n  if (str[0] === \":\" || str === \"*\") {\n    return NODE_TYPES.PLACEHOLDER;\n  }\n  return NODE_TYPES.NORMAL;\n}\n\nfunction toRouteMatcher(router) {\n  const table = _routerNodeToTable(\"\", router.ctx.rootNode);\n  return _createMatcher(table);\n}\nfunction _createMatcher(table) {\n  return {\n    ctx: { table },\n    matchAll: (path) => _matchRoutes(path, table)\n  };\n}\nfunction _createRouteTable() {\n  return {\n    static: /* @__PURE__ */ new Map(),\n    wildcard: /* @__PURE__ */ new Map(),\n    dynamic: /* @__PURE__ */ new Map()\n  };\n}\nfunction _exportMatcherFromTable(table) {\n  const obj = /* @__PURE__ */ Object.create(null);\n  for (const property in table) {\n    obj[property] = property === \"dynamic\" ? Object.fromEntries(\n      [...table[property].entries()].map(([key, value]) => [\n        key,\n        _exportMatcherFromTable(value)\n      ])\n    ) : Object.fromEntries(table[property].entries());\n  }\n  return obj;\n}\nfunction exportMatcher(matcher) {\n  return _exportMatcherFromTable(matcher.ctx.table);\n}\nfunction _createTableFromExport(matcherExport) {\n  const table = {};\n  for (const property in matcherExport) {\n    table[property] = property === \"dynamic\" ? new Map(\n      Object.entries(matcherExport[property]).map(([key, value]) => [\n        key,\n        _createTableFromExport(value)\n      ])\n    ) : new Map(Object.entries(matcherExport[property]));\n  }\n  return table;\n}\nfunction createMatcherFromExport(matcherExport) {\n  return _createMatcher(_createTableFromExport(matcherExport));\n}\nfunction _matchRoutes(path, table) {\n  const matches = [];\n  for (const [key, value] of _sortRoutesMap(table.wildcard)) {\n    if (path.startsWith(key)) {\n      matches.push(value);\n    }\n  }\n  for (const [key, value] of _sortRoutesMap(table.dynamic)) {\n    if (path.startsWith(key + \"/\")) {\n      const subPath = \"/\" + path.slice(key.length).split(\"/\").splice(2).join(\"/\");\n      matches.push(..._matchRoutes(subPath, value));\n    }\n  }\n  const staticMatch = table.static.get(path);\n  if (staticMatch) {\n    matches.push(staticMatch);\n  }\n  return matches.filter(Boolean);\n}\nfunction _sortRoutesMap(m) {\n  return [...m.entries()].sort((a, b) => a[0].length - b[0].length);\n}\nfunction _routerNodeToTable(initialPath, initialNode) {\n  const table = _createRouteTable();\n  function _addNode(path, node) {\n    if (path) {\n      if (node.type === NODE_TYPES.NORMAL && !(path.includes(\"*\") || path.includes(\":\"))) {\n        table.static.set(path, node.data);\n      } else if (node.type === NODE_TYPES.WILDCARD) {\n        table.wildcard.set(path.replace(\"/**\", \"\"), node.data);\n      } else if (node.type === NODE_TYPES.PLACEHOLDER) {\n        const subTable = _routerNodeToTable(\"\", node);\n        if (node.data) {\n          subTable.static.set(\"/\", node.data);\n        }\n        table.dynamic.set(path.replace(/\\/\\*|\\/:\\w+/, \"\"), subTable);\n        return;\n      }\n    }\n    for (const [childPath, child] of node.children.entries()) {\n      _addNode(`${path}/${childPath}`.replace(\"//\", \"/\"), child);\n    }\n  }\n  _addNode(initialPath, initialNode);\n  return table;\n}\n\nexport { NODE_TYPES, createMatcherFromExport, createRouter, exportMatcher, toRouteMatcher };\n","const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _value = value.trim();\n  if (\n    // eslint-disable-next-line unicorn/prefer-at\n    value[0] === '\"' && value.at(-1) === '\"' && !value.includes(\"\\\\\")\n  ) {\n    return _value.slice(1, -1);\n  }\n  if (_value.length <= 9) {\n    const _lval = _value.toLowerCase();\n    if (_lval === \"true\") {\n      return true;\n    }\n    if (_lval === \"false\") {\n      return false;\n    }\n    if (_lval === \"undefined\") {\n      return void 0;\n    }\n    if (_lval === \"null\") {\n      return null;\n    }\n    if (_lval === \"nan\") {\n      return Number.NaN;\n    }\n    if (_lval === \"infinity\") {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (_lval === \"-infinity\") {\n      return Number.NEGATIVE_INFINITY;\n    }\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction safeDestr(value, options = {}) {\n  return destr(value, { ...options, strict: true });\n}\n\nexport { destr as default, destr, safeDestr };\n","function _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!_isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (_isPlainObject(value) && _isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction _isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1, decode, decodePath, withLeadingSlash, parseURL } from 'ufo';\nimport { parse as parse$1, serialize } from 'cookie-es';\nimport { createRouter as createRouter$1, toRouteMatcher } from 'radix3';\nimport destr from 'destr';\nimport { defu } from 'defu';\nimport crypto from 'uncrypto';\nimport { seal, defaults, unseal } from 'iron-webcrypto';\nimport { IncomingMessage } from 'unenv/runtime/node/http/_request';\nimport { ServerResponse } from 'unenv/runtime/node/http/_response';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base || base === \"/\") {\n    return handler;\n  }\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _path = event._path || event.node.req.url || \"/\";\n    event._path = withoutBase(event.path || \"/\", base);\n    event.node.req.url = event._path;\n    try {\n      return await handler(event);\n    } finally {\n      event._path = event.node.req.url = _path;\n    }\n  });\n}\n\nfunction hasProp(obj, prop) {\n  try {\n    return prop in obj;\n  } catch {\n    return false;\n  }\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Error extends Error {\n  constructor(message, opts = {}) {\n    super(message, opts);\n    __publicField$1(this, \"statusCode\", 500);\n    __publicField$1(this, \"fatal\", false);\n    __publicField$1(this, \"unhandled\", false);\n    __publicField$1(this, \"statusMessage\");\n    __publicField$1(this, \"data\");\n    __publicField$1(this, \"cause\");\n    if (opts.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: sanitizeStatusCode(this.statusCode, 500)\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\n__publicField$1(H3Error, \"__h3_error__\", true);\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage ?? \"\", {\n    cause: input.cause || input\n  });\n  if (hasProp(input, \"stack\")) {\n    try {\n      Object.defineProperty(err, \"stack\", {\n        get() {\n          return input.stack;\n        }\n      });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);\n  } else if (input.status) {\n    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (err.statusMessage) {\n    const originalMessage = err.statusMessage;\n    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);\n    if (sanitizedMessage !== originalMessage) {\n      console.warn(\n        \"[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.\"\n      );\n    }\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.handled) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.handled) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  setResponseStatus(event, _code, h3Error.statusMessage);\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction parse(multipartBodyBuffer, boundary) {\n  let lastline = \"\";\n  let state = 0 /* INIT */;\n  let buffer = [];\n  const allParts = [];\n  let currentPartHeaders = [];\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n    const currByte = multipartBodyBuffer[i];\n    const newLineChar = currByte === 10 || currByte === 13;\n    if (!newLineChar) {\n      lastline += String.fromCodePoint(currByte);\n    }\n    const newLineDetected = currByte === 10 && prevByte === 13;\n    if (0 /* INIT */ === state && newLineDetected) {\n      if (\"--\" + boundary === lastline) {\n        state = 1 /* READING_HEADERS */;\n      }\n      lastline = \"\";\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\n      if (lastline.length > 0) {\n        const i2 = lastline.indexOf(\":\");\n        if (i2 > 0) {\n          const name = lastline.slice(0, i2).toLowerCase();\n          const value = lastline.slice(i2 + 1).trim();\n          currentPartHeaders.push([name, value]);\n        }\n      } else {\n        state = 2 /* READING_DATA */;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (2 /* READING_DATA */ === state) {\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\";\n      }\n      if (\"--\" + boundary === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n        allParts.push(process(part, currentPartHeaders));\n        buffer = [];\n        currentPartHeaders = [];\n        lastline = \"\";\n        state = 3 /* READING_PART_SEPARATOR */;\n      } else {\n        buffer.push(currByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\n      state = 1 /* READING_HEADERS */;\n    }\n  }\n  return allParts;\n}\nfunction process(data, headers) {\n  const dataObj = {};\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\n  for (const i of contentDispositionHeader.split(\";\")) {\n    const s = i.split(\"=\");\n    if (s.length !== 2) {\n      continue;\n    }\n    const key = (s[0] || \"\").trim();\n    if (key === \"name\" || key === \"filename\") {\n      const _value = (s[1] || \"\").trim().replace(/\"/g, \"\");\n      dataObj[key] = Buffer.from(_value, \"latin1\").toString(\"utf8\");\n    }\n  }\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\n  if (contentType) {\n    dataObj.type = contentType;\n  }\n  dataObj.data = Buffer.from(data);\n  return dataObj;\n}\n\nasync function validateData(data, fn) {\n  try {\n    const res = await fn(data);\n    if (res === false) {\n      throw createValidationError();\n    }\n    if (res === true) {\n      return data;\n    }\n    return res ?? data;\n  } catch (error) {\n    throw createValidationError(error);\n  }\n}\nfunction createValidationError(validateError) {\n  throw createError({\n    status: 400,\n    message: validateError.message || \"Validation Failed\",\n    ...validateError\n  });\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.path || \"\");\n}\nfunction getValidatedQuery(event, validate) {\n  const query = getQuery(event);\n  return validateData(query, validate);\n}\nfunction getRouterParams(event, opts = {}) {\n  let params = event.context.params || {};\n  if (opts.decode) {\n    params = { ...params };\n    for (const key in params) {\n      params[key] = decode(params[key]);\n    }\n  }\n  return params;\n}\nfunction getValidatedRouterParams(event, validate, opts = {}) {\n  const routerParams = getRouterParams(event, opts);\n  return validateData(routerParams, validate);\n}\nfunction getRouterParam(event, name, opts = {}) {\n  const params = getRouterParams(event, opts);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  if (allowHead && event.method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (event.method === expected) {\n      return true;\n    }\n  } else if (expected.includes(event.method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\nfunction getRequestHost(event, opts = {}) {\n  if (opts.xForwardedHost) {\n    const xForwardedHost = event.node.req.headers[\"x-forwarded-host\"];\n    if (xForwardedHost) {\n      return xForwardedHost;\n    }\n  }\n  return event.node.req.headers.host || \"localhost\";\n}\nfunction getRequestProtocol(event, opts = {}) {\n  if (opts.xForwardedProto !== false && event.node.req.headers[\"x-forwarded-proto\"] === \"https\") {\n    return \"https\";\n  }\n  return event.node.req.connection?.encrypted ? \"https\" : \"http\";\n}\nconst DOUBLE_SLASH_RE = /[/\\\\]{2,}/g;\nfunction getRequestPath(event) {\n  const path = (event.node.req.url || \"/\").replace(DOUBLE_SLASH_RE, \"/\");\n  return path;\n}\nfunction getRequestURL(event, opts = {}) {\n  const host = getRequestHost(event, opts);\n  const protocol = getRequestProtocol(event);\n  const path = (event.node.req.originalUrl || event.path).replace(\n    /^[/\\\\]+/g,\n    \"/\"\n  );\n  return new URL(path, `${protocol}://${host}`);\n}\nfunction toWebRequest(event) {\n  return event.web?.request || new Request(getRequestURL(event), {\n    // @ts-ignore Undici option\n    duplex: \"half\",\n    method: event.method,\n    headers: event.headers,\n    body: getRequestWebStream(event)\n  });\n}\nfunction getRequestIP(event, opts = {}) {\n  if (event.context.clientAddress) {\n    return event.context.clientAddress;\n  }\n  if (opts.xForwardedFor) {\n    const xForwardedFor = getRequestHeader(event, \"x-forwarded-for\")?.split(\",\")?.pop();\n    if (xForwardedFor) {\n      return xForwardedFor;\n    }\n  }\n  if (event.node.req.socket.remoteAddress) {\n    return event.node.req.socket.remoteAddress;\n  }\n}\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.body;\n  if (_rawBody) {\n    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {\n      if (Buffer.isBuffer(_resolved)) {\n        return _resolved;\n      }\n      if (typeof _resolved.pipeTo === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.pipeTo(\n            new WritableStream({\n              write(chunk) {\n                chunks.push(chunk);\n              },\n              close() {\n                resolve(Buffer.concat(chunks));\n              },\n              abort(reason) {\n                reject(reason);\n              }\n            })\n          ).catch(reject);\n        });\n      } else if (typeof _resolved.pipe === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.on(\"data\", (chunk) => {\n            chunks.push(chunk);\n          }).on(\"end\", () => {\n            resolve(Buffer.concat(chunks));\n          }).on(\"error\", reject);\n        });\n      }\n      if (_resolved.constructor === Object) {\n        return Buffer.from(JSON.stringify(_resolved));\n      }\n      return Buffer.from(_resolved);\n    });\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise(\n    (resolve, reject) => {\n      const bodyData = [];\n      event.node.req.on(\"error\", (err) => {\n        reject(err);\n      }).on(\"data\", (chunk) => {\n        bodyData.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(bodyData));\n      });\n    }\n  );\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n  return result;\n}\nasync function readBody(event, options = {}) {\n  const request = event.node.req;\n  if (hasProp(request, ParsedBodySymbol)) {\n    return request[ParsedBodySymbol];\n  }\n  const contentType = request.headers[\"content-type\"] || \"\";\n  const body = await readRawBody(event);\n  let parsed;\n  if (contentType === \"application/json\") {\n    parsed = _parseJSON(body, options.strict ?? true);\n  } else if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n    parsed = _parseURLEncodedBody(body);\n  } else if (contentType.startsWith(\"text/\")) {\n    parsed = body;\n  } else {\n    parsed = _parseJSON(body, options.strict ?? false);\n  }\n  request[ParsedBodySymbol] = parsed;\n  return parsed;\n}\nasync function readValidatedBody(event, validate) {\n  const _body = await readBody(event, { strict: true });\n  return validateData(_body, validate);\n}\nasync function readMultipartFormData(event) {\n  const contentType = getRequestHeader(event, \"content-type\");\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\n    return;\n  }\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\n  if (!boundary) {\n    return;\n  }\n  const body = await readRawBody(event, false);\n  if (!body) {\n    return;\n  }\n  return parse(body, boundary);\n}\nasync function readFormData(event) {\n  return await toWebRequest(event).formData();\n}\nfunction getRequestWebStream(event) {\n  if (!PayloadMethods$1.includes(event.method)) {\n    return;\n  }\n  return event.web?.request?.body || event._requestBody || new ReadableStream({\n    start: (controller) => {\n      event.node.req.on(\"data\", (chunk) => {\n        controller.enqueue(chunk);\n      });\n      event.node.req.on(\"end\", () => {\n        controller.close();\n      });\n      event.node.req.on(\"error\", (err) => {\n        controller.error(err);\n      });\n    }\n  });\n}\nfunction _parseJSON(body = \"\", strict) {\n  if (!body) {\n    return void 0;\n  }\n  try {\n    return destr(body, { strict });\n  } catch {\n    throw createError({\n      statusCode: 400,\n      statusMessage: \"Bad Request\",\n      message: \"Invalid JSON body\"\n    });\n  }\n}\nfunction _parseURLEncodedBody(body) {\n  const form = new URLSearchParams(body);\n  const parsedForm = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of form.entries()) {\n    if (hasProp(parsedForm, key)) {\n      if (!Array.isArray(parsedForm[key])) {\n        parsedForm[key] = [parsedForm[key]];\n      }\n      parsedForm[key].push(value);\n    } else {\n      parsedForm[key] = value;\n    }\n  }\n  return parsedForm;\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    if (!event.handled) {\n      event.node.res.end();\n    }\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst DISALLOWED_STATUS_CHARS = /[^\\u0009\\u0020-\\u007E]/g;\nfunction sanitizeStatusMessage(statusMessage = \"\") {\n  return statusMessage.replace(DISALLOWED_STATUS_CHARS, \"\");\n}\nfunction sanitizeStatusCode(statusCode, defaultStatusCode = 200) {\n  if (!statusCode) {\n    return defaultStatusCode;\n  }\n  if (typeof statusCode === \"string\") {\n    statusCode = Number.parseInt(statusCode, 10);\n  }\n  if (statusCode < 100 || statusCode > 999) {\n    return defaultStatusCode;\n  }\n  return statusCode;\n}\n\nfunction parseCookies(event) {\n  return parse$1(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  let setCookies = event.node.res.getHeader(\"set-cookie\");\n  if (!Array.isArray(setCookies)) {\n    setCookies = [setCookies];\n  }\n  setCookies = setCookies.filter((cookieValue) => {\n    return cookieValue && !cookieValue.startsWith(name + \"=\");\n  });\n  event.node.res.setHeader(\"set-cookie\", [...setCookies, cookieStr]);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitCookiesString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\nconst defer = typeof setImmediate === \"undefined\" ? (fn) => fn() : setImmediate;\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      if (!event.handled) {\n        event.node.res.end(data);\n      }\n      resolve();\n    });\n  });\n}\nfunction sendNoContent(event, code) {\n  if (event.handled) {\n    return;\n  }\n  if (!code && event.node.res.statusCode !== 200) {\n    code = event.node.res.statusCode;\n  }\n  const _code = sanitizeStatusCode(code, 204);\n  if (_code === 204) {\n    event.node.res.removeHeader(\"content-length\");\n  }\n  event.node.res.writeHead(_code);\n  event.node.res.end();\n}\nfunction setResponseStatus(event, code, text) {\n  if (code) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      code,\n      event.node.res.statusCode\n    );\n  }\n  if (text) {\n    event.node.res.statusMessage = sanitizeStatusMessage(text);\n  }\n}\nfunction getResponseStatus(event) {\n  return event.node.res.statusCode;\n}\nfunction getResponseStatusText(event) {\n  return event.node.res.statusMessage;\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = sanitizeStatusCode(\n    code,\n    event.node.res.statusCode\n  );\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(name, value);\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction clearResponseHeaders(event, headerNames) {\n  if (headerNames && headerNames.length > 0) {\n    for (const name of headerNames) {\n      removeResponseHeader(event, name);\n    }\n  } else {\n    for (const [name] of Object.entries(getResponseHeaders(event))) {\n      removeResponseHeader(event, name);\n    }\n  }\n}\nfunction removeResponseHeader(event, name) {\n  return event.node.res.removeHeader(name);\n}\nfunction isStream(data) {\n  if (!data || typeof data !== \"object\") {\n    return false;\n  }\n  if (typeof data.pipe === \"function\") {\n    if (typeof data._read === \"function\") {\n      return true;\n    }\n    if (typeof data.abort === \"function\") {\n      return true;\n    }\n  }\n  if (typeof data.pipeTo === \"function\") {\n    return true;\n  }\n  return false;\n}\nfunction isWebResponse(data) {\n  return typeof Response !== \"undefined\" && data instanceof Response;\n}\nfunction sendStream(event, stream) {\n  if (!stream || typeof stream !== \"object\") {\n    throw new Error(\"[h3] Invalid stream provided.\");\n  }\n  event.node.res._data = stream;\n  if (!event.node.res.socket) {\n    event._handled = true;\n    return Promise.resolve();\n  }\n  if (hasProp(stream, \"pipeTo\") && typeof stream.pipeTo === \"function\") {\n    return stream.pipeTo(\n      new WritableStream({\n        write(chunk) {\n          event.node.res.write(chunk);\n        }\n      })\n    ).then(() => {\n      event.node.res.end();\n    });\n  }\n  if (hasProp(stream, \"pipe\") && typeof stream.pipe === \"function\") {\n    return new Promise((resolve, reject) => {\n      stream.pipe(event.node.res);\n      if (stream.on) {\n        stream.on(\"end\", () => {\n          event.node.res.end();\n          resolve();\n        });\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      }\n      event.node.res.on(\"close\", () => {\n        if (stream.abort) {\n          stream.abort();\n        }\n      });\n    });\n  }\n  throw new Error(\"[h3] Invalid or incompatible stream provided.\");\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map(\n    (e) => [e[0].toLowerCase(), e[1]]\n  );\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  if (event.node.res.socket) {\n    event.node.res.socket.write(\n      `${hint}\\r\n\\r\n`,\n      \"utf8\",\n      cb\n    );\n  } else {\n    cb();\n  }\n}\nfunction sendWebResponse(event, response) {\n  for (const [key, value] of response.headers) {\n    if (key === \"set-cookie\") {\n      event.node.res.appendHeader(key, splitCookiesString(value));\n    } else {\n      event.node.res.setHeader(key, value);\n    }\n  }\n  if (response.status) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      response.status,\n      event.node.res.statusCode\n    );\n  }\n  if (response.statusText) {\n    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  }\n  if (response.redirected) {\n    event.node.res.setHeader(\"location\", response.url);\n  }\n  if (!response.body) {\n    event.node.res.end();\n    return;\n  }\n  return sendStream(event, response.body);\n}\n\nfunction resolveCorsOptions(options = {}) {\n  const defaultOptions = {\n    origin: \"*\",\n    methods: \"*\",\n    allowHeaders: \"*\",\n    exposeHeaders: \"*\",\n    credentials: false,\n    maxAge: false,\n    preflight: {\n      statusCode: 204\n    }\n  };\n  return defu(options, defaultOptions);\n}\nfunction isPreflightRequest(event) {\n  const origin = getRequestHeader(event, \"origin\");\n  const accessControlRequestMethod = getRequestHeader(\n    event,\n    \"access-control-request-method\"\n  );\n  return event.method === \"OPTIONS\" && !!origin && !!accessControlRequestMethod;\n}\nfunction isCorsOriginAllowed(origin, options) {\n  const { origin: originOption } = options;\n  if (!origin || !originOption || originOption === \"*\" || originOption === \"null\") {\n    return true;\n  }\n  if (Array.isArray(originOption)) {\n    return originOption.some((_origin) => {\n      if (_origin instanceof RegExp) {\n        return _origin.test(origin);\n      }\n      return origin === _origin;\n    });\n  }\n  return originOption(origin);\n}\nfunction createOriginHeaders(event, options) {\n  const { origin: originOption } = options;\n  const origin = getRequestHeader(event, \"origin\");\n  if (!origin || !originOption || originOption === \"*\") {\n    return { \"access-control-allow-origin\": \"*\" };\n  }\n  if (typeof originOption === \"string\") {\n    return { \"access-control-allow-origin\": originOption, vary: \"origin\" };\n  }\n  return isCorsOriginAllowed(origin, options) ? { \"access-control-allow-origin\": origin, vary: \"origin\" } : {};\n}\nfunction createMethodsHeaders(options) {\n  const { methods } = options;\n  if (!methods) {\n    return {};\n  }\n  if (methods === \"*\") {\n    return { \"access-control-allow-methods\": \"*\" };\n  }\n  return methods.length > 0 ? { \"access-control-allow-methods\": methods.join(\",\") } : {};\n}\nfunction createCredentialsHeaders(options) {\n  const { credentials } = options;\n  if (credentials) {\n    return { \"access-control-allow-credentials\": \"true\" };\n  }\n  return {};\n}\nfunction createAllowHeaderHeaders(event, options) {\n  const { allowHeaders } = options;\n  if (!allowHeaders || allowHeaders === \"*\" || allowHeaders.length === 0) {\n    const header = getRequestHeader(event, \"access-control-request-headers\");\n    return header ? {\n      \"access-control-allow-headers\": header,\n      vary: \"access-control-request-headers\"\n    } : {};\n  }\n  return {\n    \"access-control-allow-headers\": allowHeaders.join(\",\"),\n    vary: \"access-control-request-headers\"\n  };\n}\nfunction createExposeHeaders(options) {\n  const { exposeHeaders } = options;\n  if (!exposeHeaders) {\n    return {};\n  }\n  if (exposeHeaders === \"*\") {\n    return { \"access-control-expose-headers\": exposeHeaders };\n  }\n  return { \"access-control-expose-headers\": exposeHeaders.join(\",\") };\n}\nfunction appendCorsPreflightHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n  appendHeaders(event, createMethodsHeaders(options));\n  appendHeaders(event, createAllowHeaderHeaders(event, options));\n}\nfunction appendCorsHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n}\n\nfunction handleCors(event, options) {\n  const _options = resolveCorsOptions(options);\n  if (isPreflightRequest(event)) {\n    appendCorsPreflightHeaders(event, options);\n    sendNoContent(event, _options.preflight.statusCode);\n    return true;\n  }\n  appendCorsHeaders(event, options);\n  return false;\n}\n\nasync function getRequestFingerprint(event, opts = {}) {\n  const fingerprint = [];\n  if (opts.ip !== false) {\n    fingerprint.push(\n      getRequestIP(event, { xForwardedFor: opts.xForwardedFor })\n    );\n  }\n  if (opts.method === true) {\n    fingerprint.push(event.method);\n  }\n  if (opts.path === true) {\n    fingerprint.push(event.path);\n  }\n  if (opts.userAgent === true) {\n    fingerprint.push(getRequestHeader(event, \"user-agent\"));\n  }\n  const fingerprintString = fingerprint.filter(Boolean).join(\"|\");\n  if (!fingerprintString) {\n    return null;\n  }\n  if (opts.hash === false) {\n    return fingerprintString;\n  }\n  const buffer = await crypto.subtle.digest(\n    opts.hash || \"SHA-1\",\n    new TextEncoder().encode(fingerprintString)\n  );\n  const hash = [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hash;\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\",\n  \"host\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  let body;\n  let duplex;\n  if (PayloadMethods.has(event.method)) {\n    if (opts.streamRequest) {\n      body = getRequestWebStream(event);\n      duplex = \"half\";\n    } else {\n      body = await readRawBody(event, false).catch(() => void 0);\n    }\n  }\n  const method = opts.fetchOptions?.method || event.method;\n  const fetchHeaders = mergeHeaders(\n    getProxyRequestHeaders(event),\n    opts.fetchOptions?.headers,\n    opts.headers\n  );\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      method,\n      body,\n      duplex,\n      ...opts.fetchOptions,\n      headers: fetchHeaders\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  const response = await _getFetch(opts.fetch)(target, {\n    headers: opts.headers,\n    ignoreResponseError: true,\n    // make $ofetch.raw transparent\n    ...opts.fetchOptions\n  });\n  event.node.res.statusCode = sanitizeStatusCode(\n    response.status,\n    event.node.res.statusCode\n  );\n  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  const cookies = [];\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    if (key === \"set-cookie\") {\n      cookies.push(...splitCookiesString(value));\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  if (cookies.length > 0) {\n    event.node.res.setHeader(\n      \"set-cookie\",\n      cookies.map((cookie) => {\n        if (opts.cookieDomainRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookieDomainRewrite,\n            \"domain\"\n          );\n        }\n        if (opts.cookiePathRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookiePathRewrite,\n            \"path\"\n          );\n        }\n        return cookie;\n      })\n    );\n  }\n  if (opts.onResponse) {\n    await opts.onResponse(event, response);\n  }\n  if (response._data !== void 0) {\n    return response._data;\n  }\n  if (event.handled) {\n    return;\n  }\n  if (opts.sendStream === false) {\n    const data = new Uint8Array(await response.arrayBuffer());\n    return event.node.res.end(data);\n  }\n  if (response.body) {\n    for await (const chunk of response.body) {\n      event.node.res.write(chunk);\n    }\n  }\n  return event.node.res.end();\n}\nfunction getProxyRequestHeaders(event) {\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  return headers;\n}\nfunction fetchWithEvent(event, req, init, options) {\n  return _getFetch(options?.fetch)(req, {\n    ...init,\n    context: init?.context || event.context,\n    headers: {\n      ...getProxyRequestHeaders(event),\n      ...init?.headers\n    }\n  });\n}\nfunction _getFetch(_fetch) {\n  if (_fetch) {\n    return _fetch;\n  }\n  if (globalThis.fetch) {\n    return globalThis.fetch;\n  }\n  throw new Error(\n    \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\n  );\n}\nfunction rewriteCookieProperty(header, map, property) {\n  const _map = typeof map === \"string\" ? { \"*\": map } : map;\n  return header.replace(\n    new RegExp(`(;\\\\s*${property}=)([^;]+)`, \"gi\"),\n    (match, prefix, previousValue) => {\n      let newValue;\n      if (previousValue in _map) {\n        newValue = _map[previousValue];\n      } else if (\"*\" in _map) {\n        newValue = _map[\"*\"];\n      } else {\n        return match;\n      }\n      return newValue ? prefix + newValue : \"\";\n    }\n  );\n}\nfunction mergeHeaders(defaults, ...inputs) {\n  const _inputs = inputs.filter(Boolean);\n  if (_inputs.length === 0) {\n    return defaults;\n  }\n  const merged = new Headers(defaults);\n  for (const input of _inputs) {\n    for (const [key, value] of Object.entries(input)) {\n      if (value !== void 0) {\n        merged.set(key, value);\n      }\n    }\n  }\n  return merged;\n}\n\nconst DEFAULT_NAME = \"h3\";\nconst DEFAULT_COOKIE = {\n  path: \"/\",\n  secure: true,\n  httpOnly: true\n};\nasync function useSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  await getSession(event, config);\n  const sessionManager = {\n    get id() {\n      return event.context.sessions?.[sessionName]?.id;\n    },\n    get data() {\n      return event.context.sessions?.[sessionName]?.data || {};\n    },\n    update: async (update) => {\n      await updateSession(event, config, update);\n      return sessionManager;\n    },\n    clear: async () => {\n      await clearSession(event, config);\n      return sessionManager;\n    }\n  };\n  return sessionManager;\n}\nasync function getSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (!event.context.sessions) {\n    event.context.sessions = /* @__PURE__ */ Object.create(null);\n  }\n  if (event.context.sessions[sessionName]) {\n    return event.context.sessions[sessionName];\n  }\n  const session = {\n    id: \"\",\n    createdAt: 0,\n    data: /* @__PURE__ */ Object.create(null)\n  };\n  event.context.sessions[sessionName] = session;\n  let sealedSession;\n  if (config.sessionHeader !== false) {\n    const headerName = typeof config.sessionHeader === \"string\" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;\n    const headerValue = event.node.req.headers[headerName];\n    if (typeof headerValue === \"string\") {\n      sealedSession = headerValue;\n    }\n  }\n  if (!sealedSession) {\n    sealedSession = getCookie(event, sessionName);\n  }\n  if (sealedSession) {\n    const unsealed = await unsealSession(event, config, sealedSession).catch(\n      () => {\n      }\n    );\n    Object.assign(session, unsealed);\n  }\n  if (!session.id) {\n    session.id = config.generateId?.() ?? (config.crypto || crypto).randomUUID();\n    session.createdAt = Date.now();\n    await updateSession(event, config);\n  }\n  return session;\n}\nasync function updateSession(event, config, update) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  if (typeof update === \"function\") {\n    update = update(session.data);\n  }\n  if (update) {\n    Object.assign(session.data, update);\n  }\n  if (config.cookie !== false) {\n    const sealed = await sealSession(event, config);\n    setCookie(event, sessionName, sealed, {\n      ...DEFAULT_COOKIE,\n      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,\n      ...config.cookie\n    });\n  }\n  return session;\n}\nasync function sealSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  const sealed = await seal(config.crypto || crypto, session, config.password, {\n    ...defaults,\n    ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n    ...config.seal\n  });\n  return sealed;\n}\nasync function unsealSession(_event, config, sealed) {\n  const unsealed = await unseal(\n    config.crypto || crypto,\n    sealed,\n    config.password,\n    {\n      ...defaults,\n      ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n      ...config.seal\n    }\n  );\n  if (config.maxAge) {\n    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);\n    if (age > config.maxAge * 1e3) {\n      throw new Error(\"Session expired!\");\n    }\n  }\n  return unsealed;\n}\nasync function clearSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (event.context.sessions?.[sessionName]) {\n    delete event.context.sessions[sessionName];\n  }\n  await setCookie(event, sessionName, \"\", {\n    ...DEFAULT_COOKIE,\n    ...config.cookie\n  });\n}\n\nasync function serveStatic(event, options) {\n  if (event.method !== \"GET\" && event.method !== \"HEAD\") {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Method Not Allowed\",\n        statusCode: 405\n      });\n    }\n    return false;\n  }\n  const originalId = decodePath(\n    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))\n  );\n  const acceptEncodings = parseAcceptEncoding(\n    getRequestHeader(event, \"accept-encoding\"),\n    options.encodings\n  );\n  if (acceptEncodings.length > 1) {\n    setResponseHeader(event, \"vary\", \"accept-encoding\");\n  }\n  let id = originalId;\n  let meta;\n  const _ids = idSearchPaths(\n    originalId,\n    acceptEncodings,\n    options.indexNames || [\"/index.html\"]\n  );\n  for (const _id of _ids) {\n    const _meta = await options.getMeta(_id);\n    if (_meta) {\n      meta = _meta;\n      id = _id;\n      break;\n    }\n  }\n  if (!meta) {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Cannot find static asset \" + id,\n        statusCode: 404\n      });\n    }\n    return false;\n  }\n  const ifNotMatch = meta.etag && getRequestHeader(event, \"if-none-match\") === meta.etag;\n  if (ifNotMatch) {\n    setResponseStatus(event, 304, \"Not Modified\");\n    return send(event, \"\");\n  }\n  if (meta.mtime) {\n    const mtimeDate = new Date(meta.mtime);\n    const ifModifiedSinceH = getRequestHeader(event, \"if-modified-since\");\n    if (ifModifiedSinceH && new Date(ifModifiedSinceH) >= mtimeDate) {\n      setResponseStatus(event, 304, \"Not Modified\");\n      return send(event, null);\n    }\n    if (!getResponseHeader(event, \"last-modified\")) {\n      setResponseHeader(event, \"last-modified\", mtimeDate.toUTCString());\n    }\n  }\n  if (meta.type && !getResponseHeader(event, \"content-type\")) {\n    setResponseHeader(event, \"content-type\", meta.type);\n  }\n  if (meta.etag && !getResponseHeader(event, \"etag\")) {\n    setResponseHeader(event, \"etag\", meta.etag);\n  }\n  if (meta.encoding && !getResponseHeader(event, \"content-encoding\")) {\n    setResponseHeader(event, \"content-encoding\", meta.encoding);\n  }\n  if (meta.size !== void 0 && meta.size > 0 && !getResponseHeader(event, \"content-length\")) {\n    setResponseHeader(event, \"content-length\", meta.size);\n  }\n  if (event.method === \"HEAD\") {\n    return send(event, null);\n  }\n  const contents = await options.getContents(id);\n  return isStream(contents) ? sendStream(event, contents) : send(event, contents);\n}\nfunction parseAcceptEncoding(header, encodingMap) {\n  if (!encodingMap || !header) {\n    return [];\n  }\n  return String(header || \"\").split(\",\").map((e) => encodingMap[e.trim()]).filter(Boolean);\n}\nfunction idSearchPaths(id, encodings, indexNames) {\n  const ids = [];\n  for (const suffix of [\"\", ...indexNames]) {\n    for (const encoding of [...encodings, \"\"]) {\n      ids.push(`${id}${suffix}${encoding}`);\n    }\n  }\n  return ids;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Event {\n  constructor(req, res) {\n    __publicField(this, \"__is_event__\", true);\n    // Context\n    __publicField(this, \"node\");\n    // Node\n    __publicField(this, \"web\");\n    // Web\n    __publicField(this, \"context\", {});\n    // Shared\n    // Request\n    __publicField(this, \"_method\");\n    __publicField(this, \"_path\");\n    __publicField(this, \"_headers\");\n    __publicField(this, \"_requestBody\");\n    // Response\n    __publicField(this, \"_handled\", false);\n    this.node = { req, res };\n  }\n  // --- Request ---\n  get method() {\n    if (!this._method) {\n      this._method = (this.node.req.method || \"GET\").toUpperCase();\n    }\n    return this._method;\n  }\n  get path() {\n    return this._path || this.node.req.url || \"/\";\n  }\n  get headers() {\n    if (!this._headers) {\n      this._headers = _normalizeNodeHeaders(this.node.req.headers);\n    }\n    return this._headers;\n  }\n  // --- Respoonse ---\n  get handled() {\n    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;\n  }\n  respondWith(response) {\n    return Promise.resolve(response).then(\n      (_response) => sendWebResponse(this, _response)\n    );\n  }\n  // --- Utils ---\n  toString() {\n    return `[${this.method}] ${this.path}`;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  // --- Deprecated ---\n  /** @deprecated Please use `event.node.req` instead. **/\n  get req() {\n    return this.node.req;\n  }\n  /** @deprecated Please use `event.node.res` instead. **/\n  get res() {\n    return this.node.res;\n  }\n}\nfunction isEvent(input) {\n  return hasProp(input, \"__is_event__\");\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\nfunction _normalizeNodeHeaders(nodeHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of Object.entries(nodeHeaders)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        headers.append(name, item);\n      }\n    } else if (value) {\n      headers.set(name, value);\n    }\n  }\n  return headers;\n}\n\nfunction defineEventHandler(handler) {\n  if (typeof handler === \"function\") {\n    return Object.assign(handler, { __is_handler__: true });\n  }\n  const _hooks = {\n    onRequest: _normalizeArray(handler.onRequest),\n    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)\n  };\n  const _handler = (event) => {\n    return _callHandler(event, handler.handler, _hooks);\n  };\n  return Object.assign(_handler, { __is_handler__: true });\n}\nfunction _normalizeArray(input) {\n  return input ? Array.isArray(input) ? input : [input] : void 0;\n}\nasync function _callHandler(event, handler, hooks) {\n  if (hooks.onRequest) {\n    for (const hook of hooks.onRequest) {\n      await hook(event);\n      if (event.handled) {\n        return;\n      }\n    }\n  }\n  const body = await handler(event);\n  const response = { body };\n  if (hooks.onBeforeResponse) {\n    for (const hook of hooks.onBeforeResponse) {\n      await hook(event, response);\n    }\n  }\n  return response.body;\n}\nconst eventHandler = defineEventHandler;\nfunction defineRequestMiddleware(fn) {\n  return fn;\n}\nfunction defineResponseMiddleware(fn) {\n  return fn;\n}\nfunction isEventHandler(input) {\n  return hasProp(input, \"__is_handler__\");\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\n            \"Invalid lazy handler result. It should be a function:\",\n            handler\n          );\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nconst H3Headers = globalThis.Headers;\nconst H3Response = globalThis.Response;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const app = {\n    // @ts-ignore\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    handler,\n    stack,\n    options\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\n    );\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(\n      normalizeLayer({ ...arg2, route: \"/\", handler: arg1 })\n    );\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _reqPath = event._path || event.node.req.url || \"/\";\n    let _layerPath;\n    if (options.onRequest) {\n      await options.onRequest(event);\n    }\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!_reqPath.startsWith(layer.route)) {\n          continue;\n        }\n        _layerPath = _reqPath.slice(layer.route.length) || \"/\";\n      } else {\n        _layerPath = _reqPath;\n      }\n      if (layer.match && !layer.match(_layerPath, event)) {\n        continue;\n      }\n      event._path = _layerPath;\n      event.node.req.url = _layerPath;\n      const val = await layer.handler(event);\n      const _body = val === void 0 ? void 0 : await val;\n      if (_body !== void 0) {\n        const _response = { body: _body };\n        if (options.onBeforeResponse) {\n          await options.onBeforeResponse(event, _response);\n        }\n        await handleHandlerResponse(event, _response.body, spacing);\n        if (options.onAfterResponse) {\n          await options.onAfterResponse(event, _response);\n        }\n        return;\n      }\n      if (event.handled) {\n        if (options.onAfterResponse) {\n          await options.onAfterResponse(event, void 0);\n        }\n        return;\n      }\n    }\n    if (!event.handled) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any path matching ${event.path || \"/\"}.`\n      });\n    }\n    if (options.onAfterResponse) {\n      await options.onAfterResponse(event, void 0);\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\nfunction handleHandlerResponse(event, val, jsonSpace) {\n  if (val === null) {\n    return sendNoContent(event);\n  }\n  if (val) {\n    if (isWebResponse(val)) {\n      return sendWebResponse(event, val);\n    }\n    if (isStream(val)) {\n      return sendStream(event, val);\n    }\n    if (val.buffer) {\n      return send(event, val);\n    }\n    if (val.arrayBuffer && typeof val.arrayBuffer === \"function\") {\n      return val.arrayBuffer().then((arrayBuffer) => {\n        return send(event, Buffer.from(arrayBuffer), val.type);\n      });\n    }\n    if (val instanceof Error) {\n      throw createError(val);\n    }\n    if (typeof val.end === \"function\") {\n      return true;\n    }\n  }\n  const valType = typeof val;\n  if (valType === \"string\") {\n    return send(event, val, MIMES.html);\n  }\n  if (valType === \"object\" || valType === \"boolean\" || valType === \"number\") {\n    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);\n  }\n  if (valType === \"bigint\") {\n    return send(event, val.toString(), MIMES.json);\n  }\n  throw createError({\n    statusCode: 500,\n    statusMessage: `[h3] Cannot send ${valType} as response.`\n  });\n}\n\nconst RouterMethods = [\n  \"connect\",\n  \"delete\",\n  \"get\",\n  \"head\",\n  \"options\",\n  \"post\",\n  \"put\",\n  \"trace\",\n  \"patch\"\n];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  let _matcher;\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { path, handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.path || \"/\";\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched || !matched.handlers) {\n      if (opts.preemptive || opts.preemtive) {\n        throw createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${event.path || \"/\"}.`\n        });\n      } else {\n        return;\n      }\n    }\n    const method = (event.node.req.method || \"get\").toLowerCase();\n    let handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      if (!_matcher) {\n        _matcher = toRouteMatcher(_router);\n      }\n      const _matches = _matcher.matchAll(path).reverse();\n      for (const _match of _matches) {\n        if (_match.handlers[method]) {\n          handler = _match.handlers[method];\n          matched.handlers[method] = matched.handlers[method] || handler;\n          break;\n        }\n        if (_match.handlers.all) {\n          handler = _match.handlers.all;\n          matched.handlers.all = matched.handlers.all || handler;\n          break;\n        }\n      }\n    }\n    if (!handler) {\n      if (opts.preemptive || opts.preemtive) {\n        throw createError({\n          statusCode: 405,\n          name: \"Method Not Allowed\",\n          statusMessage: `Method ${method} is not allowed on this route.`\n        });\n      } else {\n        return;\n      }\n    }\n    event.context.matchedRoute = matched;\n    const params = matched.params || {};\n    event.context.params = params;\n    return Promise.resolve(handler(event)).then((res) => {\n      if (res === void 0 && (opts.preemptive || opts.preemtive)) {\n        return null;\n      }\n      return res;\n    });\n  });\n  return router;\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\n      \"Invalid handler. It should be a function:\",\n      handler\n    );\n  }\n  return eventHandler((event) => {\n    return callNodeListener(\n      handler,\n      event.node.req,\n      event.node.res\n    );\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      }\n      if (event.handled) {\n        return;\n      }\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      await sendError(event, error, !!app.options.debug);\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nfunction toPlainHandler(app) {\n  const handler = (request) => {\n    return _handlePlainRequest(app, request);\n  };\n  return handler;\n}\nfunction fromPlainHandler(handler) {\n  return eventHandler(async (event) => {\n    const res = await handler({\n      method: event.method,\n      path: event.path,\n      headers: Object.fromEntries(event.headers.entries()),\n      body: getRequestWebStream(event),\n      context: event.context\n    });\n    setResponseStatus(event, res.status, res.statusText);\n    for (const [key, value] of res.headers) {\n      setResponseHeader(event, key, value);\n    }\n    return res.body;\n  });\n}\nasync function _handlePlainRequest(app, request) {\n  const path = request.path;\n  const method = (request.method || \"GET\").toUpperCase();\n  const headers = new Headers(request.headers);\n  const nodeReq = new IncomingMessage();\n  const nodeRes = new ServerResponse(nodeReq);\n  nodeReq.method = method;\n  nodeReq.url = path;\n  nodeReq.headers = Object.fromEntries(headers.entries());\n  const event = createEvent(nodeReq, nodeRes);\n  event._method = method;\n  event._path = path;\n  event._headers = headers;\n  if (request.body) {\n    event._requestBody = request.body;\n  }\n  if (request._eventOverrides) {\n    Object.assign(event, request._eventOverrides);\n  }\n  if (request.context) {\n    Object.assign(event.context, request.context);\n  }\n  try {\n    await app.handler(event);\n  } catch (_error) {\n    const error = createError(_error);\n    if (!isError(_error)) {\n      error.unhandled = true;\n    }\n    if (app.options.onError) {\n      await app.options.onError(error, event);\n    }\n    if (!event.handled) {\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      await sendError(event, error, !!app.options.debug);\n    }\n  }\n  return {\n    status: nodeRes.statusCode,\n    statusText: nodeRes.statusMessage,\n    headers: _normalizeUnenvHeaders(nodeRes._headers),\n    body: nodeRes._data\n  };\n}\nfunction _normalizeUnenvHeaders(input) {\n  const headers = [];\n  const cookies = [];\n  for (const _key in input) {\n    const key = _key.toLowerCase();\n    if (key === \"set-cookie\") {\n      cookies.push(\n        ...splitCookiesString(input[\"set-cookie\"])\n      );\n      continue;\n    }\n    const value = input[key];\n    if (Array.isArray(value)) {\n      for (const _value of value) {\n        headers.push([key, _value]);\n      }\n    } else if (value !== void 0) {\n      headers.push([key, String(value)]);\n    }\n  }\n  if (cookies.length > 0) {\n    for (const cookie of cookies) {\n      headers.push([\"set-cookie\", cookie]);\n    }\n  }\n  return headers;\n}\n\nfunction toWebHandler(app) {\n  const webHandler = (request, context) => {\n    return _handleWebRequest(app, request, context);\n  };\n  return webHandler;\n}\nfunction fromWebHandler(handler) {\n  return eventHandler((event) => handler(toWebRequest(event), event.context));\n}\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nasync function _handleWebRequest(app, request, context) {\n  const url = new URL(request.url);\n  const res = await _handlePlainRequest(app, {\n    _eventOverrides: {\n      web: { request, url }\n    },\n    context,\n    method: request.method,\n    path: url.pathname + url.search,\n    headers: request.headers,\n    body: request.body\n  });\n  const body = nullBodyResponses.has(res.status) || request.method === \"HEAD\" ? null : res.body;\n  return new Response(body, {\n    status: res.status,\n    statusText: res.statusText,\n    headers: res.headers\n  });\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendCorsHeaders, appendCorsPreflightHeaders, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, clearResponseHeaders, clearSession, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, defineRequestMiddleware, defineResponseMiddleware, deleteCookie, dynamicEventHandler, eventHandler, fetchWithEvent, fromNodeMiddleware, fromPlainHandler, fromWebHandler, getCookie, getHeader, getHeaders, getMethod, getProxyRequestHeaders, getQuery, getRequestFingerprint, getRequestHeader, getRequestHeaders, getRequestHost, getRequestIP, getRequestPath, getRequestProtocol, getRequestURL, getRequestWebStream, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, getSession, getValidatedQuery, getValidatedRouterParams, handleCacheHeaders, handleCors, isCorsOriginAllowed, isError, isEvent, isEventHandler, isMethod, isPreflightRequest, isStream, isWebResponse, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readFormData, readMultipartFormData, readRawBody, readValidatedBody, removeResponseHeader, sanitizeStatusCode, sanitizeStatusMessage, sealSession, send, sendError, sendNoContent, sendProxy, sendRedirect, sendStream, sendWebResponse, serveStatic, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, splitCookiesString, toEventHandler, toNodeListener, toPlainHandler, toWebHandler, toWebRequest, unsealSession, updateSession, use, useBase, useSession, writeEarlyHints };\n","import { createError as createH3Error } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRouter } from \"./router.js\";\nexport const NUXT_ERROR_SIGNATURE = \"__nuxt_error\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (error) => {\n  const nuxtError = createError(error);\n  try {\n    const nuxtApp = useNuxtApp();\n    const error2 = useError();\n    if (import.meta.client) {\n      nuxtApp.hooks.callHook(\"app:error\", nuxtError);\n    }\n    error2.value = error2.value || nuxtError;\n  } catch {\n    throw nuxtError;\n  }\n  return nuxtError;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await useRouter().replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (error) => !!error && typeof error === \"object\" && NUXT_ERROR_SIGNATURE in error;\nexport const createError = (error) => {\n  const nuxtError = createH3Error(error);\n  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {\n    value: true,\n    configurable: false,\n    writable: false\n  });\n  return nuxtError;\n};\n","export const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appHead = {\"meta\":[{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"charset\":\"utf-8\"}],\"link\":[],\"style\":[],\"script\":[],\"noscript\":[]}\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"\n\nexport const renderJsonPayloads = true\n\nexport const componentIslands = false\n\nexport const payloadExtraction = true\n\nexport const appManifest = true\n\nexport const remoteComponentIslands = false\n\nexport const selectiveClient = false\n\nexport const devPagesDir = null\n\nexport const devRootDir = null\n\nexport const nuxtLinkDefaults = {\"componentName\":\"NuxtLink\"}\n\nexport const asyncDataDefaults = {\"deep\":true}\n\nexport const fetchDefaults = {}\n\nexport const vueAppRootContainer = '#__nuxt'","export const UNDEFINED = -1;\nexport const HOLE = -2;\nexport const NAN = -3;\nexport const POSITIVE_INFINITY = -4;\nexport const NEGATIVE_INFINITY = -5;\nexport const NEGATIVE_ZERO = -6;\n","import {\n\tHOLE,\n\tNAN,\n\tNEGATIVE_INFINITY,\n\tNEGATIVE_ZERO,\n\tPOSITIVE_INFINITY,\n\tUNDEFINED\n} from './constants.js';\n\n/**\n * Revive a value serialized with `devalue.stringify`\n * @param {string} serialized\n * @param {Record<string, (value: any) => any>} [revivers]\n */\nexport function parse(serialized, revivers) {\n\treturn unflatten(JSON.parse(serialized), revivers);\n}\n\n/**\n * Revive a value flattened with `devalue.stringify`\n * @param {number | any[]} parsed\n * @param {Record<string, (value: any) => any>} [revivers]\n */\nexport function unflatten(parsed, revivers) {\n\tif (typeof parsed === 'number') return hydrate(parsed, true);\n\n\tif (!Array.isArray(parsed) || parsed.length === 0) {\n\t\tthrow new Error('Invalid input');\n\t}\n\n\tconst values = /** @type {any[]} */ (parsed);\n\n\tconst hydrated = Array(values.length);\n\n\t/**\n\t * @param {number} index\n\t * @returns {any}\n\t */\n\tfunction hydrate(index, standalone = false) {\n\t\tif (index === UNDEFINED) return undefined;\n\t\tif (index === NAN) return NaN;\n\t\tif (index === POSITIVE_INFINITY) return Infinity;\n\t\tif (index === NEGATIVE_INFINITY) return -Infinity;\n\t\tif (index === NEGATIVE_ZERO) return -0;\n\n\t\tif (standalone) throw new Error(`Invalid input`);\n\n\t\tif (index in hydrated) return hydrated[index];\n\n\t\tconst value = values[index];\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\thydrated[index] = value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\tif (typeof value[0] === 'string') {\n\t\t\t\tconst type = value[0];\n\n\t\t\t\tconst reviver = revivers?.[type];\n\t\t\t\tif (reviver) {\n\t\t\t\t\treturn (hydrated[index] = reviver(hydrate(value[1])));\n\t\t\t\t}\n\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'Date':\n\t\t\t\t\t\thydrated[index] = new Date(value[1]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Set':\n\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\thydrated[index] = set;\n\t\t\t\t\t\tfor (let i = 1; i < value.length; i += 1) {\n\t\t\t\t\t\t\tset.add(hydrate(value[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Map':\n\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\thydrated[index] = map;\n\t\t\t\t\t\tfor (let i = 1; i < value.length; i += 2) {\n\t\t\t\t\t\t\tmap.set(hydrate(value[i]), hydrate(value[i + 1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RegExp':\n\t\t\t\t\t\thydrated[index] = new RegExp(value[1], value[2]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\thydrated[index] = Object(value[1]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BigInt':\n\t\t\t\t\t\thydrated[index] = BigInt(value[1]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'null':\n\t\t\t\t\t\tconst obj = Object.create(null);\n\t\t\t\t\t\thydrated[index] = obj;\n\t\t\t\t\t\tfor (let i = 1; i < value.length; i += 2) {\n\t\t\t\t\t\t\tobj[value[i]] = hydrate(value[i + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unknown type ${type}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst array = new Array(value.length);\n\t\t\t\thydrated[index] = array;\n\n\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\tconst n = value[i];\n\t\t\t\t\tif (n === HOLE) continue;\n\n\t\t\t\t\tarray[i] = hydrate(n);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/** @type {Record<string, any>} */\n\t\t\tconst object = {};\n\t\t\thydrated[index] = object;\n\n\t\t\tfor (const key in value) {\n\t\t\t\tconst n = value[key];\n\t\t\t\tobject[key] = hydrate(n);\n\t\t\t}\n\t\t}\n\n\t\treturn hydrated[index];\n\t}\n\n\treturn hydrate(0);\n}\n","\nimport { updateAppConfig } from '#app/config'\nimport { defuFn } from 'defu'\n\nconst inlineConfig = {\n  \"nuxt\": {\n    \"buildId\": \"4aa0e0c5-95d5-4679-a2e3-ff651dcbd75e\"\n  }\n}\n\n// Vite - webpack is handled directly in #app/config\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    updateAppConfig(newModule.default)\n  })\n}\n\n\n\nexport default /*@__PURE__*/ defuFn(inlineConfig)\n","import { reactive } from \"vue\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"./nuxt.js\";\nimport __appConfig from \"#build/app.config.mjs\";\nexport const _getAppConfig = () => __appConfig;\nfunction deepDelete(obj, newObj) {\n  for (const key in obj) {\n    const val = newObj[key];\n    if (!(key in newObj)) {\n      delete obj[key];\n    }\n    if (val !== null && typeof val === \"object\") {\n      deepDelete(obj[key], newObj[key]);\n    }\n  }\n}\nfunction deepAssign(obj, newObj) {\n  for (const key in newObj) {\n    const val = newObj[key];\n    if (val !== null && typeof val === \"object\") {\n      obj[key] = obj[key] || {};\n      deepAssign(obj[key], val);\n    } else {\n      obj[key] = val;\n    }\n  }\n}\nexport function useAppConfig() {\n  const nuxtApp = useNuxtApp();\n  if (!nuxtApp._appConfig) {\n    nuxtApp._appConfig = import.meta.server ? klona(__appConfig) : reactive(__appConfig);\n  }\n  return nuxtApp._appConfig;\n}\nexport function updateAppConfig(appConfig) {\n  const _appConfig = useAppConfig();\n  deepAssign(_appConfig, appConfig);\n}\nif (import.meta.dev) {\n  const applyHMR = (newConfig) => {\n    const appConfig = useAppConfig();\n    if (newConfig && appConfig) {\n      deepAssign(appConfig, newConfig);\n      deepDelete(appConfig, newConfig);\n    }\n  };\n  if (import.meta.hot) {\n    import.meta.hot.accept((newModule) => {\n      const newConfig = newModule?._getAppConfig();\n      applyHMR(newConfig);\n    });\n  }\n  if (import.meta.webpackHot) {\n    import.meta.webpackHot.accept(\"#build/app.config.mjs\", () => {\n      applyHMR(__appConfig);\n    });\n  }\n}\n","import { createMatcherFromExport } from \"radix3\";\nimport { defu } from \"defu\";\nimport { useAppConfig } from \"../config.js\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport { buildAssetsURL } from \"#build/paths.mjs\";\nlet manifest;\nlet matcher;\nfunction fetchManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  const buildId = useAppConfig().nuxt?.buildId;\n  manifest = $fetch(buildAssetsURL(`builds/meta/${buildId}.json`));\n  manifest.then((m) => {\n    matcher = createMatcherFromExport(m.matcher);\n  });\n  return manifest;\n}\nexport function getAppManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  return manifest || fetchManifest();\n}\nexport async function getRouteRules(url) {\n  await getAppManifest();\n  return defu({}, ...matcher.matchAll(url).reverse());\n}\n","import { hasProtocol, joinURL, withoutTrailingSlash } from \"ufo\";\nimport { parse } from \"devalue\";\nimport { useHead } from \"@unhead/vue\";\nimport { getCurrentInstance } from \"vue\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { useRoute } from \"./router.js\";\nimport { getAppManifest, getRouteRules } from \"./manifest.js\";\nimport { appManifest, payloadExtraction, renderJsonPayloads } from \"#build/nuxt.config.mjs\";\nexport function loadPayload(url, opts = {}) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadURL = _getPayloadURL(url, opts);\n  const nuxtApp = useNuxtApp();\n  const cache = nuxtApp._payloadCache = nuxtApp._payloadCache || {};\n  if (payloadURL in cache) {\n    return cache[payloadURL];\n  }\n  cache[payloadURL] = isPrerendered(url).then((prerendered) => {\n    if (!prerendered) {\n      cache[payloadURL] = null;\n      return null;\n    }\n    return _importPayload(payloadURL).then((payload) => {\n      if (payload) {\n        return payload;\n      }\n      delete cache[payloadURL];\n      return null;\n    });\n  });\n  return cache[payloadURL];\n}\nexport function preloadPayload(url, opts = {}) {\n  const payloadURL = _getPayloadURL(url, opts);\n  useHead({\n    link: [\n      { rel: \"modulepreload\", href: payloadURL }\n    ]\n  });\n}\nconst extension = renderJsonPayloads ? \"json\" : \"js\";\nfunction _getPayloadURL(url, opts = {}) {\n  const u = new URL(url, \"http://localhost\");\n  if (u.search) {\n    throw new Error(\"Payload URL cannot contain search params: \" + url);\n  }\n  if (u.host !== \"localhost\" || hasProtocol(u.pathname, { acceptRelative: true })) {\n    throw new Error(\"Payload URL must not include hostname: \" + url);\n  }\n  const hash = opts.hash || (opts.fresh ? Date.now() : \"\");\n  return joinURL(useRuntimeConfig().app.baseURL, u.pathname, hash ? `_payload.${hash}.${extension}` : `_payload.${extension}`);\n}\nasync function _importPayload(payloadURL) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadPromise = renderJsonPayloads ? fetch(payloadURL).then((res) => res.text().then(parsePayload)) : import(\n    /* webpackIgnore: true */\n    /* @vite-ignore */\n    payloadURL\n  ).then((r) => r.default || r);\n  try {\n    return await payloadPromise;\n  } catch (err) {\n    console.warn(\"[nuxt] Cannot load payload \", payloadURL, err);\n  }\n  return null;\n}\nexport async function isPrerendered(url = useRoute().path) {\n  if (!appManifest) {\n    return !!useNuxtApp().payload.prerenderedAt;\n  }\n  url = withoutTrailingSlash(url);\n  const manifest = await getAppManifest();\n  if (manifest.prerendered.includes(url)) {\n    return true;\n  }\n  const rules = await getRouteRules(url);\n  return !!rules.prerender && !rules.redirect;\n}\nlet payloadCache = null;\nexport async function getNuxtClientPayload() {\n  if (import.meta.server) {\n    return;\n  }\n  if (payloadCache) {\n    return payloadCache;\n  }\n  const el = document.getElementById(\"__NUXT_DATA__\");\n  if (!el) {\n    return {};\n  }\n  const inlineData = parsePayload(el.textContent || \"\");\n  const externalData = el.dataset.src ? await _importPayload(el.dataset.src) : void 0;\n  payloadCache = {\n    ...inlineData,\n    ...externalData,\n    ...window.__NUXT__\n  };\n  return payloadCache;\n}\nexport function parsePayload(payload) {\n  return parse(payload, useNuxtApp()._payloadRevivers);\n}\nexport function definePayloadReducer(name, reduce) {\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._payloadReducers[name] = reduce;\n  }\n}\nexport function definePayloadReviver(name, revive) {\n  if (import.meta.dev && getCurrentInstance()) {\n    console.warn(\"[nuxt] [definePayloadReviver] This function must be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.\");\n  }\n  if (import.meta.client) {\n    useNuxtApp()._payloadRevivers[name] = revive;\n  }\n}\n","import destr from \"destr\";\nimport { useNuxtApp } from \"../nuxt.js\";\nexport function reloadNuxtApp(options = {}) {\n  if (import.meta.server) {\n    return;\n  }\n  const path = options.path || window.location.pathname;\n  let handledPath = {};\n  try {\n    handledPath = destr(sessionStorage.getItem(\"nuxt:reload\") || \"{}\");\n  } catch {\n  }\n  if (options.force || handledPath?.path !== path || handledPath?.expires < Date.now()) {\n    try {\n      sessionStorage.setItem(\"nuxt:reload\", JSON.stringify({ path, expires: Date.now() + (options.ttl ?? 1e4) }));\n    } catch {\n    }\n    if (options.persistState) {\n      try {\n        sessionStorage.setItem(\"nuxt:reload:state\", JSON.stringify({ state: useNuxtApp().payload.state }));\n      } catch {\n      }\n    }\n    if (window.location.pathname !== path) {\n      window.location.href = path;\n    } else {\n      window.location.reload();\n    }\n  }\n}\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor(message, opts) {\n    super(message, opts);\n    this.name = \"FetchError\";\n    if (opts?.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n}\nfunction createFetchError(ctx) {\n  const errorMessage = ctx.error?.message || ctx.error?.toString() || \"\";\n  const method = ctx.request?.method || ctx.options?.method || \"GET\";\n  const url = ctx.request?.url || String(ctx.request) || \"/\";\n  const requestStr = `[${method}] ${JSON.stringify(url)}`;\n  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : \"<no response>\";\n  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : \"\"}`;\n  const fetchError = new FetchError(\n    message,\n    ctx.error ? { cause: ctx.error } : void 0\n  );\n  for (const key of [\"request\", \"options\", \"response\"]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx[key];\n      }\n    });\n  }\n  for (const [key, refKey] of [\n    [\"data\", \"_data\"],\n    [\"status\", \"status\"],\n    [\"statusCode\", \"status\"],\n    [\"statusText\", \"statusText\"],\n    [\"statusMessage\", \"statusText\"]\n  ]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx.response && ctx.response[refKey];\n      }\n    });\n  }\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction mergeFetchOptions(input, defaults, Headers = globalThis.Headers) {\n  const merged = {\n    ...defaults,\n    ...input\n  };\n  if (defaults?.params && input?.params) {\n    merged.params = {\n      ...defaults?.params,\n      ...input?.params\n    };\n  }\n  if (defaults?.query && input?.query) {\n    merged.query = {\n      ...defaults?.query,\n      ...input?.query\n    };\n  }\n  if (defaults?.headers && input?.headers) {\n    merged.headers = new Headers(defaults?.headers || {});\n    for (const [key, value] of new Headers(input?.headers || {})) {\n      merged.headers.set(key, value);\n    }\n  }\n  return merged;\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  //  Gateway Timeout\n]);\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nfunction createFetch(globalOptions = {}) {\n  const {\n    fetch = globalThis.fetch,\n    Headers = globalThis.Headers,\n    AbortController = globalThis.AbortController\n  } = globalOptions;\n  async function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" && !context.options.timeout || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {\n        const retryDelay = context.options.retryDelay || 0;\n        if (retryDelay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        }\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1,\n          timeout: context.options.timeout\n        });\n      }\n    }\n    const error = createFetchError(context);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: mergeFetchOptions(_options, globalOptions.defaults, Headers),\n      response: void 0,\n      error: void 0\n    };\n    context.options.method = context.options.method?.toUpperCase();\n    if (context.options.onRequest) {\n      await context.options.onRequest(context);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = withBase(context.request, context.options.baseURL);\n      }\n      if (context.options.query || context.options.params) {\n        context.request = withQuery(context.request, {\n          ...context.options.params,\n          ...context.options.query\n        });\n      }\n    }\n    if (context.options.body && isPayloadMethod(context.options.method)) {\n      if (isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers || {});\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      } else if (\n        // ReadableStream Body\n        \"pipeTo\" in context.options.body && typeof context.options.body.pipeTo === \"function\" || // Node.js Stream Body\n        typeof context.options.body.pipe === \"function\"\n      ) {\n        if (!(\"duplex\" in context.options)) {\n          context.options.duplex = \"half\";\n        }\n      }\n    }\n    if (!context.options.signal && context.options.timeout) {\n      const controller = new AbortController();\n      setTimeout(() => controller.abort(), context.options.timeout);\n      context.options.signal = controller.signal;\n    }\n    try {\n      context.response = await fetch(\n        context.request,\n        context.options\n      );\n    } catch (error) {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await context.options.onRequestError(context);\n      }\n      return await onError(context);\n    }\n    const hasBody = context.response.body && !nullBodyResponses.has(context.response.status) && context.options.method !== \"HEAD\";\n    if (hasBody) {\n      const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n      switch (responseType) {\n        case \"json\": {\n          const data = await context.response.text();\n          const parseFunction = context.options.parseResponse || destr;\n          context.response._data = parseFunction(data);\n          break;\n        }\n        case \"stream\": {\n          context.response._data = context.response.body;\n          break;\n        }\n        default: {\n          context.response._data = await context.response[responseType]();\n        }\n      }\n    }\n    if (context.options.onResponse) {\n      await context.options.onResponse(context);\n    }\n    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await context.options.onResponseError(context);\n      }\n      return await onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = async function $fetch2(request, options) {\n    const r = await $fetchRaw(request, options);\n    return r._data;\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = (...args) => fetch(...args);\n  $fetch.create = (defaultOptions = {}) => createFetch({\n    ...globalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { c as createFetch } from './shared/ofetch.00501375.mjs';\nexport { F as FetchError, a as createFetchError } from './shared/ofetch.00501375.mjs';\nimport 'destr';\nimport 'ufo';\n\nconst _globalThis = function() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}();\nconst fetch = _globalThis.fetch || (() => Promise.reject(new Error(\"[ofetch] global.fetch is not supported!\")));\nconst Headers = _globalThis.Headers;\nconst AbortController = _globalThis.AbortController;\nconst ofetch = createFetch({ fetch, Headers, AbortController });\nconst $fetch = ofetch;\n\nexport { $fetch, AbortController, Headers, createFetch, fetch, ofetch };\n","import { $fetch } from 'ofetch'\nimport { baseURL } from '#build/paths.mjs'\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  })\n}","import { reactive, ref, shallowReactive, shallowRef } from \"vue\";\nimport destr from \"destr\";\nimport { definePayloadReviver, getNuxtClientPayload } from \"../composables/payload.js\";\nimport { createError } from \"../composables/error.js\";\nimport { defineNuxtPlugin, useNuxtApp } from \"../nuxt.js\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nconst revivers = {\n  NuxtError: (data) => createError(data),\n  EmptyShallowRef: (data) => shallowRef(data === \"_\" ? void 0 : data === \"0n\" ? BigInt(0) : destr(data)),\n  EmptyRef: (data) => ref(data === \"_\" ? void 0 : data === \"0n\" ? BigInt(0) : destr(data)),\n  ShallowRef: (data) => shallowRef(data),\n  ShallowReactive: (data) => shallowReactive(data),\n  Ref: (data) => ref(data),\n  Reactive: (data) => reactive(data)\n};\nif (componentIslands) {\n  revivers.Island = ({ key, params, result }) => {\n    const nuxtApp = useNuxtApp();\n    if (!nuxtApp.isHydrating) {\n      nuxtApp.payload.data[key] = nuxtApp.payload.data[key] || $fetch(`/__nuxt_island/${key}.json`, {\n        responseType: \"json\",\n        ...params ? { params } : {}\n      }).then((r) => {\n        nuxtApp.payload.data[key] = r;\n        return r;\n      });\n    }\n    return {\n      html: \"\",\n      state: {},\n      head: {\n        link: [],\n        style: []\n      },\n      ...result\n    };\n  };\n}\nexport default defineNuxtPlugin({\n  name: \"nuxt:revive-payload:client\",\n  order: -30,\n  async setup(nuxtApp) {\n    for (const reviver in revivers) {\n      definePayloadReviver(reviver, revivers[reviver]);\n    }\n    Object.assign(nuxtApp.payload, await nuxtApp.runWithContext(getNuxtClientPayload));\n    window.__NUXT__ = nuxtApp.payload;\n  }\n});\n","import { createNuxtApp, defineNuxtPlugin } from \"nuxt/app\";\nimport { getContext } from \"unctx\";\nimport { createRouter, createWebHistory } from \"vue-router\";\nimport plugins from \"#build/plugins\";\nimport \"#build/css\";\nconst globalWindow = window;\nconst logger = console;\nexport default defineNuxtPlugin({\n  name: \"storybook-nuxt-plugin\",\n  enforce: \"pre\",\n  // or 'post'\n  setup(nuxtApp) {\n    logger.log(\"\\u{1F50C} \\u{1F50C} \\u{1F50C}  [storybook-nuxt-plugin] setup \", { nuxtApp });\n    const nuxtMainApp = getContext(\"nuxt-app\");\n    if (nuxtMainApp)\n      logger.info(\"\\u{1F50C}  [storybook-nuxt-plugin] setup already done \", nuxtMainApp);\n    if (nuxtApp.globalName !== \"nuxt\")\n      return;\n    const applyNuxtPlugins = async (vueApp, storyContext) => {\n      const nuxt = createNuxtApp({ vueApp, globalName: `nuxt-${storyContext.id}` });\n      getContext(\"nuxt-app\").set(nuxt, true);\n      const router = nuxtApp.$router ?? createRouter({ history: createWebHistory(), routes: [] });\n      nuxt.$router = router;\n      getContext(nuxt.globalName).set(nuxt, true);\n      nuxt.hooks.callHook(\"app:created\", vueApp);\n      for (const plugin of plugins) {\n        try {\n          if (typeof plugin === \"function\" && !plugin.toString().includes(\"definePayloadReviver\"))\n            await vueApp.runWithContext(() => plugin(nuxt));\n        } catch (e) {\n          logger.error(\"Error in plugin \", plugin);\n        }\n      }\n      return nuxt;\n    };\n    globalWindow.PLUGINS_SETUP_FUNCTIONS ||= /* @__PURE__ */ new Set();\n    globalWindow.PLUGINS_SETUP_FUNCTIONS.add(applyNuxtPlugins);\n  },\n  hooks: {\n    \"app:created\": function() {\n    }\n  }\n});\n","export default []","import { createHead as createClientHead, setHeadInjectionHandler } from \"@unhead/vue\";\nimport { renderDOMHead } from \"@unhead/dom\";\nimport { defineNuxtPlugin, useNuxtApp } from \"#app/nuxt\";\nimport unheadPlugins from \"#build/unhead-plugins.mjs\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:head\",\n  enforce: \"pre\",\n  setup(nuxtApp) {\n    const head = import.meta.server ? nuxtApp.ssrContext.head : createClientHead({\n      plugins: unheadPlugins\n    });\n    setHeadInjectionHandler(\n      // need a fresh instance of the nuxt app to avoid parallel requests interfering with each other\n      () => useNuxtApp().vueApp._context.provides.usehead\n    );\n    nuxtApp.vueApp.use(head);\n    if (import.meta.client) {\n      let pauseDOMUpdates = true;\n      const syncHead = async () => {\n        pauseDOMUpdates = false;\n        await renderDOMHead(head);\n      };\n      head.hooks.hook(\"dom:beforeRender\", (context) => {\n        context.shouldRender = !pauseDOMUpdates;\n      });\n      nuxtApp.hooks.hook(\"page:start\", () => {\n        pauseDOMUpdates = true;\n      });\n      nuxtApp.hooks.hook(\"page:finish\", () => {\n        if (!nuxtApp.isHydrating) {\n          syncHead();\n        }\n      });\n      nuxtApp.hooks.hook(\"app:error\", syncHead);\n      nuxtApp.hooks.hook(\"app:suspense:resolve\", syncHead);\n    }\n  }\n});\n","import { KeepAlive, h } from \"vue\";\nconst interpolatePath = (route, match) => {\n  return match.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (routeProps, override) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => import.meta.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n","import { default as index1rMsBD30GhMeta } from \"/mnt/data/web_projects/nuxt3-project/pages/index.vue?macro=true\";\nimport { default as index3O67kYlWvxMeta } from \"/mnt/data/web_projects/nuxt3-project/pages/query/index.vue?macro=true\";\nimport { default as indexU2YYGwgkmWMeta } from \"/mnt/data/web_projects/nuxt3-project/pages/request/index.vue?macro=true\";\nexport default [\n  {\n    name: index1rMsBD30GhMeta?.name ?? \"index\",\n    path: index1rMsBD30GhMeta?.path ?? \"/\",\n    meta: index1rMsBD30GhMeta || {},\n    alias: index1rMsBD30GhMeta?.alias || [],\n    redirect: index1rMsBD30GhMeta?.redirect || undefined,\n    component: () => import(\"/mnt/data/web_projects/nuxt3-project/pages/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: index3O67kYlWvxMeta?.name ?? \"query\",\n    path: index3O67kYlWvxMeta?.path ?? \"/query\",\n    meta: index3O67kYlWvxMeta || {},\n    alias: index3O67kYlWvxMeta?.alias || [],\n    redirect: index3O67kYlWvxMeta?.redirect || undefined,\n    component: () => import(\"/mnt/data/web_projects/nuxt3-project/pages/query/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexU2YYGwgkmWMeta?.name ?? \"request\",\n    path: indexU2YYGwgkmWMeta?.path ?? \"/request\",\n    meta: indexU2YYGwgkmWMeta || {},\n    alias: indexU2YYGwgkmWMeta?.alias || [],\n    redirect: indexU2YYGwgkmWMeta?.redirect || undefined,\n    component: () => import(\"/mnt/data/web_projects/nuxt3-project/pages/request/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: \"storybook-iframe\",\n    path: \"/iframe.html\"\n  }\n]","import { h } from \"vue\";\nimport { isString, isPromise, isArray, isObject } from \"@vue/shared\";\nimport destr from \"destr\";\nexport const _wrapIf = (component, props, slots) => {\n  props = props === true ? {} : props;\n  return { default: () => props ? h(component, props, slots) : slots.default?.() };\n};\nfunction generateRouteKey(route) {\n  const source = route?.meta.key ?? route.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n  return typeof source === \"function\" ? source(route) : source;\n}\nexport function isChangingPage(to, from) {\n  if (to === from) {\n    return false;\n  }\n  if (generateRouteKey(to) !== generateRouteKey(from)) {\n    return true;\n  }\n  const areComponentsSame = to.matched.every(\n    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default\n  );\n  if (areComponentsSame) {\n    return false;\n  }\n  return true;\n}\nexport function createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n      } else {\n        buffer.push(item);\n      }\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nconst TRANSLATE_RE = /&(nbsp|amp|quot|lt|gt);/g;\nconst NUMSTR_RE = /&#(\\d+);/gi;\nexport function decodeHtmlEntities(html) {\n  const translateDict = {\n    nbsp: \" \",\n    amp: \"&\",\n    quot: '\"',\n    lt: \"<\",\n    gt: \">\"\n  };\n  return html.replace(TRANSLATE_RE, function(_, entity) {\n    return translateDict[entity];\n  }).replace(NUMSTR_RE, function(_, numStr) {\n    const num = parseInt(numStr, 10);\n    return String.fromCharCode(num);\n  });\n}\nexport function vforToArray(source) {\n  if (isArray(source)) {\n    return source;\n  } else if (isString(source)) {\n    return source.split(\"\");\n  } else if (typeof source === \"number\") {\n    if (import.meta.dev && !Number.isInteger(source)) {\n      console.warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    const array = [];\n    for (let i = 0; i < source; i++) {\n      array[i] = i;\n    }\n    return array;\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      return Array.from(\n        source,\n        (item) => item\n      );\n    } else {\n      const keys = Object.keys(source);\n      const array = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        array[i] = source[key];\n      }\n      return array;\n    }\n  }\n  return [];\n}\nexport function getFragmentHTML(element, withoutSlots = false) {\n  if (element) {\n    if (element.nodeName === \"#comment\" && element.nodeValue === \"[\") {\n      return getFragmentChildren(element, [], withoutSlots);\n    }\n    if (withoutSlots) {\n      const clone = element.cloneNode(true);\n      clone.querySelectorAll(\"[nuxt-ssr-slot-name]\").forEach((n) => {\n        n.innerHTML = \"\";\n      });\n      return [clone.outerHTML];\n    }\n    return [element.outerHTML];\n  }\n  return null;\n}\nfunction getFragmentChildren(element, blocks = [], withoutSlots = false) {\n  if (element && element.nodeName) {\n    if (isEndFragment(element)) {\n      return blocks;\n    } else if (!isStartFragment(element)) {\n      const clone = element.cloneNode(true);\n      if (withoutSlots) {\n        clone.querySelectorAll(\"[nuxt-ssr-slot-name]\").forEach((n) => {\n          n.innerHTML = \"\";\n        });\n      }\n      blocks.push(clone.outerHTML);\n    }\n    getFragmentChildren(element.nextSibling, blocks, withoutSlots);\n  }\n  return blocks;\n}\nfunction isStartFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"[\";\n}\nfunction isEndFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"]\";\n}\nconst SLOT_PROPS_RE = /<div[^>]*nuxt-ssr-slot-name=\"([^\"]*)\" nuxt-ssr-slot-data=\"([^\"]*)\"[^/|>]*>/g;\nexport function getSlotProps(html) {\n  const slotsDivs = html.matchAll(SLOT_PROPS_RE);\n  const data = {};\n  for (const slot of slotsDivs) {\n    const [_, slotName, json] = slot;\n    const slotData = destr(decodeHtmlEntities(json));\n    data[slotName] = slotData;\n  }\n  return data;\n}\n","import { nextTick } from \"vue\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { isChangingPage } from \"#app/components/utils\";\nimport { useRouter } from \"#app/composables/router\";\nimport { appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    const behavior = useRouter().options?.scrollBehaviorType ?? \"auto\";\n    let position = savedPosition || void 0;\n    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === \"function\" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;\n    if (!position && from && to && routeAllowsScrollToTop !== false && isChangingPage(to, from)) {\n      position = { left: 0, top: 0 };\n    }\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior };\n      }\n    }\n    const hasTransition = (route) => !!(route.meta.pageTransition ?? defaultPageTransition);\n    const hookToWait = hasTransition(from) && hasTransition(to) ? \"page:transition:finish\" : \"page:finish\";\n    return new Promise((resolve) => {\n      nuxtApp.hooks.hookOnce(hookToWait, async () => {\n        await nextTick();\n        if (to.hash) {\n          position = { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior };\n        }\n        resolve(position);\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  try {\n    const elem = document.querySelector(selector);\n    if (elem) {\n      return parseFloat(getComputedStyle(elem).scrollMarginTop);\n    }\n  } catch {\n  }\n  return 0;\n}\n","import routerOptions0 from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/pages/runtime/router.options\";\nconst configRouterOptions = {\n  hashMode: false,\n  scrollBehaviorType: \"auto\"\n}\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import { createError, showError } from \"#app/composables/error\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { defineNuxtRouteMiddleware, useRouter } from \"#app/composables/router\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  const router = useRouter();\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (result === true) {\n    return;\n  }\n  if (import.meta.server) {\n    return result;\n  }\n  const error = createError({\n    statusCode: 404,\n    statusMessage: `Page Not Found: ${to.fullPath}`,\n    data: {\n      path: to.fullPath\n    }\n  });\n  const unsub = router.beforeResolve((final) => {\n    unsub();\n    if (final === to) {\n      const unsub2 = router.afterEach(async () => {\n        unsub2();\n        await nuxtApp.runWithContext(() => showError(error));\n        window.history.pushState({}, \"\", to.fullPath);\n      });\n      return false;\n    }\n  });\n});\n","import { defineNuxtRouteMiddleware } from \"../composables/router.js\";\nimport { getRouteRules } from \"../composables/manifest.js\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (import.meta.server || import.meta.test) {\n    return;\n  }\n  const rules = await getRouteRules(to.path);\n  if (rules.redirect) {\n    return rules.redirect;\n  }\n});\n","import validate from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/pages/runtime/validate.js\";\nimport manifest_45route_45rule from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/app/middleware/manifest-route-rule.js\";\nexport const globalMiddleware = [\n  validate,\n  manifest_45route_45rule\n]\nexport const namedMiddleware = {}","import { isReadonly, reactive, shallowReactive, shallowRef } from \"vue\";\nimport {\n  START_LOCATION,\n  createMemoryHistory,\n  createRouter,\n  createWebHashHistory,\n  createWebHistory\n} from \"#vue-router\";\nimport { createError } from \"h3\";\nimport { isEqual, withoutBase } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { clearError, showError, useError } from \"#app/composables/error\";\nimport { navigateTo } from \"#app/composables/router\";\nimport _routes from \"#build/routes\";\nimport routerOptions from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location, renderedPath) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const displayedPath = withoutBase(pathname, base);\n  const path = !renderedPath || isEqual(displayedPath, renderedPath, { trailingSlash: true }) ? displayedPath : renderedPath;\n  return path + (path.includes(\"?\") ? \"\" : search) + hash;\n}\nconst plugin = defineNuxtPlugin({\n  name: \"nuxt:router\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    let routerBase = useRuntimeConfig().app.baseURL;\n    if (routerOptions.hashMode && !routerBase.includes(\"#\")) {\n      routerBase += \"#\";\n    }\n    const history = routerOptions.history?.(routerBase) ?? (import.meta.client ? routerOptions.hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n    const routes = routerOptions.routes?.(_routes) ?? _routes;\n    let startPosition;\n    const initialURL = import.meta.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path);\n    const router = createRouter({\n      ...routerOptions,\n      scrollBehavior: (to, from, savedPosition) => {\n        if (from === START_LOCATION) {\n          startPosition = savedPosition;\n          return;\n        }\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n        return routerOptions.scrollBehavior?.(to, START_LOCATION, startPosition || savedPosition);\n      },\n      history,\n      routes\n    });\n    nuxtApp.vueApp.use(router);\n    const previousRoute = shallowRef(router.currentRoute.value);\n    router.afterEach((_to, from) => {\n      previousRoute.value = from;\n    });\n    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n      get: () => previousRoute.value\n    });\n    const _route = shallowRef(router.resolve(initialURL));\n    const syncCurrentRoute = () => {\n      _route.value = router.currentRoute.value;\n    };\n    nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n    router.afterEach((to, from) => {\n      if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n        syncCurrentRoute();\n      }\n    });\n    const route = {};\n    for (const key in _route.value) {\n      Object.defineProperty(route, key, {\n        get: () => _route.value[key]\n      });\n    }\n    nuxtApp._route = shallowReactive(route);\n    nuxtApp._middleware = nuxtApp._middleware || {\n      global: [],\n      named: {}\n    };\n    const error = useError();\n    try {\n      if (import.meta.server) {\n        await router.push(initialURL);\n      }\n      await router.isReady();\n    } catch (error2) {\n      await nuxtApp.runWithContext(() => showError(error2));\n    }\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {\n      return { provide: { router } };\n    }\n    const initialLayout = nuxtApp.payload.state._layout;\n    router.beforeEach(async (to, from) => {\n      await nuxtApp.callHook(\"page:loading:start\");\n      to.meta = reactive(to.meta);\n      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {\n        to.meta.layout = initialLayout;\n      }\n      nuxtApp._processingMiddleware = true;\n      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n        for (const component of to.matched) {\n          const componentMiddleware = component.meta.middleware;\n          if (!componentMiddleware) {\n            continue;\n          }\n          for (const entry of toArray(componentMiddleware)) {\n            middlewareEntries.add(entry);\n          }\n        }\n        for (const entry of middlewareEntries) {\n          const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n          if (!middleware) {\n            if (import.meta.dev) {\n              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n            }\n            throw new Error(`Unknown route middleware: '${entry}'.`);\n          }\n          const result = await nuxtApp.runWithContext(() => middleware(to, from));\n          if (import.meta.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n            if (result === false || result instanceof Error) {\n              const error2 = result || createError({\n                statusCode: 404,\n                statusMessage: `Page Not Found: ${initialURL}`\n              });\n              await nuxtApp.runWithContext(() => showError(error2));\n              return false;\n            }\n          }\n          if (result === true) {\n            continue;\n          }\n          if (result || result === false) {\n            return result;\n          }\n        }\n      }\n    });\n    router.onError(async () => {\n      delete nuxtApp._processingMiddleware;\n      await nuxtApp.callHook(\"page:loading:end\");\n    });\n    router.afterEach(async (to, _from, failure) => {\n      delete nuxtApp._processingMiddleware;\n      if (import.meta.client && !nuxtApp.isHydrating && error.value) {\n        await nuxtApp.runWithContext(clearError);\n      }\n      if (failure) {\n        await nuxtApp.callHook(\"page:loading:end\");\n      }\n      if (import.meta.server && failure?.type === 4) {\n        return;\n      }\n      if (to.matched.length === 0) {\n        await nuxtApp.runWithContext(() => showError(createError({\n          statusCode: 404,\n          fatal: false,\n          statusMessage: `Page not found: ${to.fullPath}`,\n          data: {\n            path: to.fullPath\n          }\n        })));\n      } else if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {\n        await nuxtApp.runWithContext(() => navigateTo(to.fullPath || \"/\"));\n      }\n    });\n    nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n      try {\n        await router.replace({\n          ...router.resolve(initialURL),\n          name: void 0,\n          // #4920, #4982\n          force: true\n        });\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n      } catch (error2) {\n        await nuxtApp.runWithContext(() => showError(error2));\n      }\n    });\n    return { provide: { router } };\n  }\n});\nexport default plugin;\n","import { parseURL } from \"ufo\";\nimport { defineNuxtPlugin } from \"../nuxt.js\";\nimport { loadPayload } from \"../composables/payload.js\";\nimport { onNuxtReady } from \"../composables/ready.js\";\nimport { useRouter } from \"../composables/router.js\";\nimport { getAppManifest } from \"../composables/manifest.js\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:payload\",\n  setup(nuxtApp) {\n    if (import.meta.dev) {\n      return;\n    }\n    useRouter().beforeResolve(async (to, from) => {\n      if (to.path === from.path) {\n        return;\n      }\n      const payload = await loadPayload(to.path);\n      if (!payload) {\n        return;\n      }\n      Object.assign(nuxtApp.static.data, payload.data);\n    });\n    onNuxtReady(() => {\n      nuxtApp.hooks.hook(\"link:prefetch\", async (url) => {\n        if (!parseURL(url).protocol) {\n          await loadPayload(url);\n        }\n      });\n      if (isAppManifestEnabled && navigator.connection?.effectiveType !== \"slow-2g\") {\n        setTimeout(getAppManifest, 1e3);\n      }\n    });\n  }\n});\n","import { defineNuxtPlugin } from \"../nuxt.js\";\nimport { getAppManifest } from \"../composables/manifest.js\";\nimport { onNuxtReady } from \"../composables/ready.js\";\nimport { buildAssetsURL } from \"#build/paths.mjs\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  if (import.meta.test) {\n    return;\n  }\n  let timeout;\n  async function getLatestManifest() {\n    const currentManifest = await getAppManifest();\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(getLatestManifest, 1e3 * 60 * 60);\n    const meta = await $fetch(buildAssetsURL(\"builds/latest.json\"));\n    if (meta.id !== currentManifest.id) {\n      nuxtApp.hooks.callHook(\"app:manifest:update\", meta);\n    }\n  }\n  onNuxtReady(() => {\n    timeout = setTimeout(getLatestManifest, 1e3 * 60 * 60);\n  });\n});\n","\nimport { defineNuxtPlugin } from '#app/nuxt'\nexport default defineNuxtPlugin({\n  name: 'nuxt:global-components',\n})\n","export default {\n  default: () => import(\"/mnt/data/web_projects/nuxt3-project/layouts/default.vue\").then(m => m.default || m)\n}","import { hasProtocol } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { defineNuxtPlugin } from \"#app/nuxt\";\nimport { useRouter } from \"#app/composables/router\";\nimport layouts from \"#build/layouts\";\nimport { namedMiddleware } from \"#build/middleware\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:prefetch\",\n  setup(nuxtApp) {\n    const router = useRouter();\n    nuxtApp.hooks.hook(\"app:mounted\", () => {\n      router.beforeEach(async (to) => {\n        const layout = to?.meta?.layout;\n        if (layout && typeof layouts[layout] === \"function\") {\n          await layouts[layout]();\n        }\n      });\n    });\n    nuxtApp.hooks.hook(\"link:prefetch\", (url) => {\n      if (hasProtocol(url)) {\n        return;\n      }\n      const route = router.resolve(url);\n      if (!route) {\n        return;\n      }\n      const layout = route.meta.layout;\n      let middleware = toArray(route.meta.middleware);\n      middleware = middleware.filter((m) => typeof m === \"string\");\n      for (const name of middleware) {\n        if (typeof namedMiddleware[name] === \"function\") {\n          namedMiddleware[name]();\n        }\n      }\n      if (layout && typeof layouts[layout] === \"function\") {\n        layouts[layout]();\n      }\n    });\n  }\n});\n","import { joinURL } from \"ufo\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"../nuxt.js\";\nimport { useRouter } from \"../composables/router.js\";\nimport { reloadNuxtApp } from \"../composables/chunk.js\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:chunk-reload\",\n  setup(nuxtApp) {\n    const router = useRouter();\n    const config = useRuntimeConfig();\n    const chunkErrors = /* @__PURE__ */ new Set();\n    router.beforeEach(() => {\n      chunkErrors.clear();\n    });\n    nuxtApp.hook(\"app:chunkError\", ({ error }) => {\n      chunkErrors.add(error);\n    });\n    function reloadAppAtPath(to) {\n      const isHash = \"href\" in to && to.href.startsWith(\"#\");\n      const path = isHash ? config.app.baseURL + to.href : joinURL(config.app.baseURL, to.fullPath);\n      reloadNuxtApp({ path, persistState: true });\n    }\n    nuxtApp.hook(\"app:manifest:update\", () => {\n      router.beforeResolve(reloadAppAtPath);\n    });\n    router.onError((error, to) => {\n      if (chunkErrors.has(error)) {\n        reloadAppAtPath(to);\n      }\n    });\n  }\n});\n","import revive_payload_client_4sVQNw7RlN from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/app/plugins/revive-payload.client.js\";\nimport storybook_LiuGAqG6Vu from \"/mnt/data/web_projects/nuxt3-project/node_modules/@storybook-vue/nuxt/dist/runtime/plugins/storybook.js\";\nimport unhead_KgADcZ0jPj from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/head/runtime/plugins/unhead.js\";\nimport router_jmwsqit4Rs from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/pages/runtime/plugins/router.js\";\nimport payload_client_yVLowv6hDl from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/app/plugins/payload.client.js\";\nimport check_outdated_build_client_8vK7RkfGxZ from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/app/plugins/check-outdated-build.client.js\";\nimport components_plugin_KR1HBZs4kY from \"/mnt/data/web_projects/nuxt3-project/.nuxt/components.plugin.mjs\";\nimport prefetch_client_5tzzN0oIVL from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/pages/runtime/plugins/prefetch.client.js\";\nimport chunk_reload_client_UciE0i6zes from \"/mnt/data/web_projects/nuxt3-project/node_modules/nuxt/dist/app/plugins/chunk-reload.client.js\";\nexport default [\n  revive_payload_client_4sVQNw7RlN,\n  storybook_LiuGAqG6Vu,\n  unhead_KgADcZ0jPj,\n  router_jmwsqit4Rs,\n  payload_client_yVLowv6hDl,\n  check_outdated_build_client_8vK7RkfGxZ,\n  components_plugin_KR1HBZs4kY,\n  prefetch_client_5tzzN0oIVL,\n  chunk_reload_client_UciE0i6zes\n]","import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from \"vue\";\nimport { PageRouteSymbol } from \"./injections.js\";\nexport const RouteProvider = defineComponent({\n  props: {\n    vnode: {\n      type: Object,\n      required: true\n    },\n    route: {\n      type: Object,\n      required: true\n    },\n    vnodeRef: Object,\n    renderKey: String,\n    trackRootNodes: Boolean\n  },\n  setup(props) {\n    const previousKey = props.renderKey;\n    const previousRoute = props.route;\n    const route = {};\n    for (const key in props.route) {\n      Object.defineProperty(route, key, {\n        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key]\n      });\n    }\n    provide(PageRouteSymbol, shallowReactive(route));\n    let vnode;\n    if (import.meta.dev && import.meta.client && props.trackRootNodes) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = (vnode?.type).__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (import.meta.dev && import.meta.client) {\n        vnode = h(props.vnode, { ref: props.vnodeRef });\n        return vnode;\n      }\n      return h(props.vnode, { ref: props.vnodeRef });\n    };\n  }\n});\n","import { Suspense, Transition, defineComponent, h, inject, nextTick, ref, watch } from \"vue\";\nimport { RouterView } from \"#vue-router\";\nimport { defu } from \"defu\";\nimport { toArray } from \"./utils.js\";\nimport { generateRouteKey, wrapInKeepAlive } from \"./utils.js\";\nimport { RouteProvider } from \"#app/components/route-provider\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { _wrapIf } from \"#app/components/utils\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"#app/components/injections\";\nimport { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs, expose }) {\n    const nuxtApp = useNuxtApp();\n    const pageRef = ref();\n    const forkRoute = inject(PageRouteSymbol, null);\n    expose({ pageRef });\n    const _layoutMeta = inject(LayoutMetaSymbol, null);\n    let vnode;\n    const done = nuxtApp.deferHydration();\n    if (props.pageKey) {\n      watch(() => props.pageKey, (next, prev) => {\n        if (next !== prev) {\n          nuxtApp.callHook(\"page:loading:start\");\n        }\n      });\n    }\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: (routeProps) => {\n          const isRenderingNewRouteInOldFork = import.meta.client && haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);\n          const hasSameChildren = import.meta.client && forkRoute && forkRoute.matched.length === routeProps.route.matched.length;\n          if (!routeProps.Component) {\n            if (import.meta.client && vnode && !hasSameChildren) {\n              return vnode;\n            }\n            done();\n            return;\n          }\n          if (import.meta.client && vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {\n            return vnode;\n          }\n          if (import.meta.client && isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {\n            if (hasSameChildren) {\n              return vnode;\n            }\n            return null;\n          }\n          const key = generateRouteKey(routeProps, props.pageKey);\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            { onAfterLeave: () => {\n              nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n            } }\n          ].filter(Boolean));\n          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig;\n          vnode = _wrapIf(\n            Transition,\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              keepaliveConfig,\n              h(Suspense, {\n                suspensible: true,\n                onPending: () => nuxtApp.callHook(\"page:start\", routeProps.Component),\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).then(() => nuxtApp.callHook(\"page:loading:end\")).finally(done));\n                }\n              }, {\n                default: () => {\n                  const providerVNode = h(RouteProvider, {\n                    key: key || void 0,\n                    vnode: routeProps.Component,\n                    route: routeProps.route,\n                    renderKey: key || void 0,\n                    trackRootNodes: hasTransition,\n                    vnodeRef: pageRef\n                  });\n                  if (import.meta.client && keepaliveConfig) {\n                    providerVNode.type.name = routeProps.Component.type.name || routeProps.Component.type.__name || \"RouteProvider\";\n                  }\n                  return providerVNode;\n                }\n              })\n            )\n          ).default();\n          return vnode;\n        }\n      });\n    };\n  }\n});\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.map((prop) => ({\n    ...prop,\n    onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : void 0\n  }));\n  return defu(..._props);\n}\nfunction haveParentRoutesRendered(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  if (!index || index === -1) {\n    return false;\n  }\n  return newRoute.matched.slice(0, index).some(\n    (c, i) => c.components?.default !== fork.matched[i]?.components?.default\n  ) || Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component });\n}\n","import { Suspense, Transition, computed, defineComponent, h, inject, mergeProps, nextTick, onMounted, provide, ref, unref } from \"vue\";\nimport { useRoute } from \"../composables/router.js\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { _wrapIf } from \"./utils.js\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"./injections.js\";\nimport { useRoute as useVueRouterRoute } from \"#build/pages\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nconst LayoutLoader = defineComponent({\n  name: \"LayoutLoader\",\n  inheritAttrs: false,\n  props: {\n    name: String,\n    layoutProps: Object\n  },\n  async setup(props, context) {\n    const LayoutComponent = await layouts[props.name]().then((r) => r.default || r);\n    return () => h(LayoutComponent, props.layoutProps, context.slots);\n  }\n});\nexport default defineComponent({\n  name: \"NuxtLayout\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean, Object],\n      default: null\n    },\n    fallback: {\n      type: [String, Object],\n      default: null\n    }\n  },\n  setup(props, context) {\n    const nuxtApp = useNuxtApp();\n    const injectedRoute = inject(PageRouteSymbol);\n    const route = injectedRoute === useRoute() ? useVueRouterRoute() : injectedRoute;\n    const layout = computed(() => {\n      let layout2 = unref(props.name) ?? route.meta.layout ?? \"default\";\n      if (layout2 && !(layout2 in layouts)) {\n        if (import.meta.dev && layout2 !== \"default\") {\n          console.warn(`Invalid layout \\`${layout2}\\` selected.`);\n        }\n        if (props.fallback) {\n          layout2 = unref(props.fallback);\n        }\n      }\n      return layout2;\n    });\n    const layoutRef = ref();\n    context.expose({ layoutRef });\n    const done = nuxtApp.deferHydration();\n    if (import.meta.dev) {\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    return () => {\n      const hasLayout = layout.value && layout.value in layouts;\n      const transitionProps = route.meta.layoutTransition ?? defaultLayoutTransition;\n      return _wrapIf(Transition, hasLayout && transitionProps, {\n        default: () => h(Suspense, { suspensible: true, onResolve: () => {\n          nextTick(done);\n        } }, {\n          default: () => h(\n            LayoutProvider,\n            {\n              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),\n              key: layout.value || void 0,\n              name: layout.value,\n              shouldProvide: !props.name,\n              hasTransition: !!transitionProps\n            },\n            context.slots\n          )\n        })\n      }).default();\n    };\n  }\n});\nconst LayoutProvider = defineComponent({\n  name: \"NuxtLayoutProvider\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean]\n    },\n    layoutProps: {\n      type: Object\n    },\n    hasTransition: {\n      type: Boolean\n    },\n    shouldProvide: {\n      type: Boolean\n    }\n  },\n  setup(props, context) {\n    const name = props.name;\n    if (props.shouldProvide) {\n      provide(LayoutMetaSymbol, {\n        isCurrent: (route) => name === (route.meta.layout ?? \"default\")\n      });\n    }\n    let vnode;\n    if (import.meta.dev && import.meta.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            if (name) {\n              console.warn(`[nuxt] \\`${name}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n            } else {\n              console.warn(\"[nuxt] `<NuxtLayout>` needs to be passed a single root node in its default slot.\");\n            }\n          }\n        });\n      });\n    }\n    return () => {\n      if (!name || typeof name === \"string\" && !(name in layouts)) {\n        if (import.meta.dev && import.meta.client && props.hasTransition) {\n          vnode = context.slots.default?.();\n          return vnode;\n        }\n        return context.slots.default?.();\n      }\n      if (import.meta.dev && import.meta.client && props.hasTransition) {\n        vnode = h(\n          LayoutLoader,\n          { key: name, layoutProps: props.layoutProps, name },\n          context.slots\n        );\n        return vnode;\n      }\n      return h(\n        LayoutLoader,\n        { key: name, layoutProps: props.layoutProps, name },\n        context.slots\n      );\n    };\n  }\n});\n","<template>\n  <ErrorTemplate v-bind=\"{ statusCode, statusMessage, description, stack }\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst props = defineProps({\n  error: Object\n})\n\n// Deliberately prevent reactive update when error is cleared\nconst _error = props.error\n\n// TODO: extract to a separate utility\nconst stacktrace = (_error.stack || '')\n  .split('\\n')\n  .splice(1)\n  .map((line) => {\n    const text = line\n      .replace('webpack:/', '')\n      .replace('.vue', '.js') // TODO: Support sourcemap\n      .trim()\n    return {\n      text,\n      internal: (line.includes('node_modules') && !line.includes('.cache')) ||\n        line.includes('internal') ||\n        line.includes('new Promise')\n    }\n  }).map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')\n\n// Error page props\nconst statusCode = Number(_error.statusCode || 500)\nconst is404 = statusCode === 404\n\nconst statusMessage = _error.statusMessage ?? (is404 ? 'Page Not Found' : 'Internal Server Error')\nconst description = _error.message || _error.toString()\nconst stack = import.meta.dev && !is404 ? _error.description || `<pre>${stacktrace}</pre>` : undefined\n\n// TODO: Investigate side-effect issue with imports\nconst _Error404 = defineAsyncComponent(() => import('@nuxt/ui-templates/templates/error-404.vue').then(r => r.default || r))\nconst _Error = import.meta.dev\n  ? defineAsyncComponent(() => import('@nuxt/ui-templates/templates/error-dev.vue').then(r => r.default || r))\n  : defineAsyncComponent(() => import('@nuxt/ui-templates/templates/error-500.vue').then(r => r.default || r))\n\nconst ErrorTemplate = is404 ? _Error404 : _Error\n</script>\n","<template>\n  <Suspense @resolve=\"onResolve\">\n    <ErrorComponent\n      v-if=\"error\"\n      :error=\"error\"\n    />\n    <IslandRenderer\n      v-else-if=\"islandContext\"\n      :context=\"islandContext\"\n    />\n    <component\n      :is=\"SingleRenderer\"\n      v-else-if=\"SingleRenderer\"\n    />\n    <AppComponent v-else />\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent, onErrorCaptured, onServerPrefetch, provide } from 'vue'\nimport { useNuxtApp } from '../nuxt'\nimport { isNuxtError, showError, useError } from '../composables/error'\nimport { useRoute } from '../composables/router'\nimport { PageRouteSymbol } from '../components/injections'\nimport AppComponent from '#build/app-component.mjs'\nimport ErrorComponent from '#build/error-component.mjs'\n\nconst IslandRenderer = import.meta.server\n  ? defineAsyncComponent(() => import('./island-renderer').then(r => r.default || r))\n  : () => null\n\nconst nuxtApp = useNuxtApp()\nconst onResolve = nuxtApp.deferHydration()\n\nconst url = import.meta.server ? nuxtApp.ssrContext.url : window.location.pathname\nconst SingleRenderer = import.meta.test && import.meta.dev && import.meta.server && url.startsWith('/__nuxt_component_test__/') && defineAsyncComponent(() => import('#build/test-component-wrapper.mjs')\n  .then(r => r.default(import.meta.server ? url : window.location.href)))\n\n// Inject default route (outside of pages) as active route\nprovide(PageRouteSymbol, useRoute())\n\n// vue:setup hook\nconst results = nuxtApp.hooks.callHookWith(hooks => hooks.map(hook => hook()), 'vue:setup')\nif (import.meta.dev && results && results.some(i => i && 'then' in i)) {\n  console.error('[nuxt] Error in `vue:setup`. Callbacks must be synchronous.')\n}\n\n// error handling\nconst error = useError()\nonErrorCaptured((err, target, info) => {\n  nuxtApp.hooks.callHook('vue:error', err, target, info).catch(hookError => console.error('[nuxt] Error in `vue:error` hook', hookError))\n  if (import.meta.server || (isNuxtError(err) && (err.fatal || err.unhandled))) {\n    const p = nuxtApp.runWithContext(() => showError(err))\n    onServerPrefetch(() => p)\n    return false // suppress error from breaking render\n  }\n})\n\n// Component islands context\nconst islandContext = import.meta.server && nuxtApp.ssrContext.islandContext\n</script>\n","import { createApp, createSSRApp, nextTick } from \"vue\";\nimport \"#build/paths.mjs\";\nimport \"#build/fetch.mjs\";\nimport { applyPlugins, createNuxtApp } from \"./nuxt.js\";\nimport \"#build/css\";\nimport plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { vueAppRootContainer } from \"#build/nuxt.config.mjs\";\nlet entry;\nif (import.meta.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (err) {\n      await nuxt.hooks.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    if (ssrContext?._renderResponse) {\n      throw new Error(\"skipping render\");\n    }\n    return vueApp;\n  };\n}\nif (import.meta.client) {\n  if (import.meta.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  let vueAppPromise;\n  entry = async function initApp() {\n    if (vueAppPromise) {\n      return vueAppPromise;\n    }\n    const isSSR = Boolean(\n      window.__NUXT__?.serverRendered || document.getElementById(\"__NUXT_DATA__\")?.dataset.ssr === \"true\"\n    );\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    async function handleVueError(err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    vueApp.config.errorHandler = handleVueError;\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      handleVueError(err);\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(vueAppRootContainer);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      handleVueError(err);\n    }\n    if (vueApp.config.errorHandler === handleVueError)\n      vueApp.config.errorHandler = void 0;\n    return vueApp;\n  };\n  vueAppPromise = entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n    throw error;\n  });\n}\nexport default (ssrContext) => entry(ssrContext);\n"],"file":"_nuxt/entry.9d9e32fa.js"}