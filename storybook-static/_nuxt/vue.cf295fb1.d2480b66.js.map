{"version":3,"file":"vue.cf295fb1.d2480b66.js","sources":["../../node_modules/@unhead/shared/dist/index.mjs","../../node_modules/@unhead/dom/dist/index.mjs","../../node_modules/unhead/dist/index.mjs","../../node_modules/@unhead/vue/dist/shared/vue.cf295fb1.mjs"],"sourcesContent":["function asArray$1(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nconst SelfClosingTags = [\"meta\", \"link\", \"base\"];\nconst TagsWithInnerContent = [\"title\", \"titleTemplate\", \"script\", \"style\", \"noscript\"];\nconst HasElementTags = [\n  \"base\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst ValidHeadTags = [\n  \"title\",\n  \"titleTemplate\",\n  \"templateParams\",\n  \"base\",\n  \"htmlAttrs\",\n  \"bodyAttrs\",\n  \"meta\",\n  \"link\",\n  \"style\",\n  \"script\",\n  \"noscript\"\n];\nconst UniqueTags = [\"base\", \"title\", \"titleTemplate\", \"bodyAttrs\", \"htmlAttrs\", \"templateParams\"];\nconst TagConfigKeys = [\"tagPosition\", \"tagPriority\", \"tagDuplicateStrategy\", \"children\", \"innerHTML\", \"textContent\", \"processTemplateParams\"];\nconst IsBrowser = typeof window !== \"undefined\";\nconst composableNames = [\n  \"getActiveHead\",\n  \"useHead\",\n  \"useSeoMeta\",\n  \"useHeadSafe\",\n  \"useServerHead\",\n  \"useServerSeoMeta\",\n  \"useServerHeadSafe\"\n];\n\nfunction defineHeadPlugin(plugin) {\n  return plugin;\n}\n\nfunction hashCode(s) {\n  let h = 9;\n  for (let i = 0; i < s.length; )\n    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return ((h ^ h >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase();\n}\nfunction hashTag(tag) {\n  return tag._h || hashCode(tag._d ? tag._d : `${tag.tag}:${tag.textContent || tag.innerHTML || \"\"}:${Object.entries(tag.props).map(([key, value]) => `${key}:${String(value)}`).join(\",\")}`);\n}\n\nfunction tagDedupeKey(tag, fn) {\n  const { props, tag: tagName } = tag;\n  if (UniqueTags.includes(tagName))\n    return tagName;\n  if (tagName === \"link\" && props.rel === \"canonical\")\n    return \"canonical\";\n  if (props.charset)\n    return \"charset\";\n  const name = [\"id\"];\n  if (tagName === \"meta\")\n    name.push(...[\"name\", \"property\", \"http-equiv\"]);\n  for (const n of name) {\n    if (typeof props[n] !== \"undefined\") {\n      const val = String(props[n]);\n      if (fn && !fn(val))\n        return false;\n      return `${tagName}:${n}:${val}`;\n    }\n  }\n  return false;\n}\n\nfunction resolveTitleTemplate(template, title) {\n  if (template == null)\n    return title || null;\n  if (typeof template === \"function\")\n    return template(title);\n  return template;\n}\n\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nconst InternalKeySymbol = \"_$key\";\nfunction packObject(input, options) {\n  const keys = Object.keys(input);\n  let [k, v] = keys;\n  options = options || {};\n  options.key = options.key || k;\n  options.value = options.value || v;\n  options.resolveKey = options.resolveKey || ((k2) => k2);\n  const resolveKey = (index) => {\n    const arr = asArray(options?.[index]);\n    return arr.find((k2) => {\n      if (typeof k2 === \"string\" && k2.includes(\".\")) {\n        return k2;\n      }\n      return k2 && keys.includes(k2);\n    });\n  };\n  const resolveValue = (k2, input2) => {\n    if (k2.includes(\".\")) {\n      const paths = k2.split(\".\");\n      let val = input2;\n      for (const path of paths)\n        val = val[path];\n      return val;\n    }\n    return input2[k2];\n  };\n  k = resolveKey(\"key\") || k;\n  v = resolveKey(\"value\") || v;\n  const dedupeKeyPrefix = input.key ? `${InternalKeySymbol}${input.key}-` : \"\";\n  let keyValue = resolveValue(k, input);\n  keyValue = options.resolveKey(keyValue);\n  return {\n    [`${dedupeKeyPrefix}${keyValue}`]: resolveValue(v, input)\n  };\n}\n\nfunction packArray(input, options) {\n  const packed = {};\n  for (const i of input) {\n    const packedObj = packObject(i, options);\n    const pKey = Object.keys(packedObj)[0];\n    const isDedupeKey = pKey.startsWith(InternalKeySymbol);\n    if (!isDedupeKey && packed[pKey]) {\n      packed[pKey] = Array.isArray(packed[pKey]) ? packed[pKey] : [packed[pKey]];\n      packed[pKey].push(Object.values(packedObj)[0]);\n    } else {\n      packed[isDedupeKey ? pKey.split(\"-\").slice(1).join(\"-\") || pKey : pKey] = packedObj[pKey];\n    }\n  }\n  return packed;\n}\n\nfunction unpackToArray(input, options) {\n  const unpacked = [];\n  const kFn = options.resolveKeyData || ((ctx) => ctx.key);\n  const vFn = options.resolveValueData || ((ctx) => ctx.value);\n  for (const [k, v] of Object.entries(input)) {\n    unpacked.push(...(Array.isArray(v) ? v : [v]).map((i) => {\n      const ctx = { key: k, value: i };\n      const val = vFn(ctx);\n      if (typeof val === \"object\")\n        return unpackToArray(val, options);\n      if (Array.isArray(val))\n        return val;\n      return {\n        [typeof options.key === \"function\" ? options.key(ctx) : options.key]: kFn(ctx),\n        [typeof options.value === \"function\" ? options.value(ctx) : options.value]: val\n      };\n    }).flat());\n  }\n  return unpacked;\n}\n\nfunction unpackToString(value, options) {\n  return Object.entries(value).map(([key, value2]) => {\n    if (typeof value2 === \"object\")\n      value2 = unpackToString(value2, options);\n    if (options.resolve) {\n      const resolved = options.resolve({ key, value: value2 });\n      if (resolved)\n        return resolved;\n    }\n    if (typeof value2 === \"number\")\n      value2 = value2.toString();\n    if (typeof value2 === \"string\" && options.wrapValue) {\n      value2 = value2.replace(new RegExp(options.wrapValue, \"g\"), `\\\\${options.wrapValue}`);\n      value2 = `${options.wrapValue}${value2}${options.wrapValue}`;\n    }\n    return `${key}${options.keyValueSeparator || \"\"}${value2}`;\n  }).join(options.entrySeparator || \"\");\n}\n\nconst p = (p2) => ({ keyValue: p2, metaKey: \"property\" });\nconst k = (p2) => ({ keyValue: p2 });\nconst MetaPackingSchema = {\n  appleItunesApp: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)}=${value}`;\n      }\n    }\n  },\n  articleExpirationTime: p(\"article:expiration_time\"),\n  articleModifiedTime: p(\"article:modified_time\"),\n  articlePublishedTime: p(\"article:published_time\"),\n  bookReleaseDate: p(\"book:release_date\"),\n  charset: {\n    metaKey: \"charset\"\n  },\n  contentSecurityPolicy: {\n    unpack: {\n      entrySeparator: \"; \",\n      resolve({ key, value }) {\n        return `${fixKeyCase(key)} ${value}`;\n      }\n    },\n    metaKey: \"http-equiv\"\n  },\n  contentType: {\n    metaKey: \"http-equiv\"\n  },\n  defaultStyle: {\n    metaKey: \"http-equiv\"\n  },\n  fbAppId: p(\"fb:app_id\"),\n  msapplicationConfig: k(\"msapplication-Config\"),\n  msapplicationTileColor: k(\"msapplication-TileColor\"),\n  msapplicationTileImage: k(\"msapplication-TileImage\"),\n  ogAudioSecureUrl: p(\"og:audio:secure_url\"),\n  ogAudioUrl: p(\"og:audio\"),\n  ogImageSecureUrl: p(\"og:image:secure_url\"),\n  ogImageUrl: p(\"og:image\"),\n  ogSiteName: p(\"og:site_name\"),\n  ogVideoSecureUrl: p(\"og:video:secure_url\"),\n  ogVideoUrl: p(\"og:video\"),\n  profileFirstName: p(\"profile:first_name\"),\n  profileLastName: p(\"profile:last_name\"),\n  profileUsername: p(\"profile:username\"),\n  refresh: {\n    metaKey: \"http-equiv\",\n    unpack: {\n      entrySeparator: \";\",\n      resolve({ key, value }) {\n        if (key === \"seconds\")\n          return `${value}`;\n      }\n    }\n  },\n  robots: {\n    unpack: {\n      entrySeparator: \", \",\n      resolve({ key, value }) {\n        if (typeof value === \"boolean\")\n          return `${fixKeyCase(key)}`;\n        else\n          return `${fixKeyCase(key)}:${value}`;\n      }\n    }\n  },\n  xUaCompatible: {\n    metaKey: \"http-equiv\"\n  }\n};\nconst openGraphNamespaces = [\n  \"og\",\n  \"book\",\n  \"article\",\n  \"profile\"\n];\nfunction resolveMetaKeyType(key) {\n  const fKey = fixKeyCase(key).split(\":\")[0];\n  if (openGraphNamespaces.includes(fKey))\n    return \"property\";\n  return MetaPackingSchema[key]?.metaKey || \"name\";\n}\nfunction resolveMetaKeyValue(key) {\n  return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);\n}\nfunction fixKeyCase(key) {\n  const updated = key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  const fKey = updated.split(\"-\")[0];\n  if (openGraphNamespaces.includes(fKey) || fKey === \"twitter\")\n    return key.replace(/([A-Z])/g, \":$1\").toLowerCase();\n  return updated;\n}\nfunction changeKeyCasingDeep(input) {\n  if (Array.isArray(input)) {\n    return input.map((entry) => changeKeyCasingDeep(entry));\n  }\n  if (typeof input !== \"object\" || Array.isArray(input))\n    return input;\n  const output = {};\n  for (const [key, value] of Object.entries(input))\n    output[fixKeyCase(key)] = changeKeyCasingDeep(value);\n  return output;\n}\nfunction resolvePackedMetaObjectValue(value, key) {\n  const definition = MetaPackingSchema[key];\n  if (key === \"refresh\")\n    return `${value.seconds};url=${value.url}`;\n  return unpackToString(\n    changeKeyCasingDeep(value),\n    {\n      keyValueSeparator: \"=\",\n      entrySeparator: \", \",\n      resolve({ value: value2, key: key2 }) {\n        if (value2 === null)\n          return \"\";\n        if (typeof value2 === \"boolean\")\n          return `${key2}`;\n      },\n      ...definition?.unpack\n    }\n  );\n}\nconst ObjectArrayEntries = [\"og:image\", \"og:video\", \"og:audio\", \"twitter:image\"];\nfunction sanitize(input) {\n  const out = {};\n  Object.entries(input).forEach(([k2, v]) => {\n    if (String(v) !== \"false\" && k2)\n      out[k2] = v;\n  });\n  return out;\n}\nfunction handleObjectEntry(key, v) {\n  const value = sanitize(v);\n  const fKey = fixKeyCase(key);\n  const attr = resolveMetaKeyType(fKey);\n  if (ObjectArrayEntries.includes(fKey)) {\n    const input = {};\n    Object.entries(value).forEach(([k2, v2]) => {\n      input[`${key}${k2 === \"url\" ? \"\" : `${k2.charAt(0).toUpperCase()}${k2.slice(1)}`}`] = v2;\n    });\n    return unpackMeta(input).sort((a, b) => (a[attr]?.length || 0) - (b[attr]?.length || 0));\n  }\n  return [{ [attr]: fKey, ...value }];\n}\nfunction unpackMeta(input) {\n  const extras = [];\n  const primitives = {};\n  Object.entries(input).forEach(([key, value]) => {\n    if (!Array.isArray(value)) {\n      if (typeof value === \"object\" && value) {\n        if (ObjectArrayEntries.includes(fixKeyCase(key))) {\n          extras.push(...handleObjectEntry(key, value));\n          return;\n        }\n        primitives[key] = sanitize(value);\n      } else {\n        primitives[key] = value;\n      }\n      return;\n    }\n    value.forEach((v) => {\n      extras.push(...typeof v === \"string\" ? unpackMeta({ [key]: v }) : handleObjectEntry(key, v));\n    });\n  });\n  const meta = unpackToArray(primitives, {\n    key({ key }) {\n      return resolveMetaKeyType(key);\n    },\n    value({ key }) {\n      return key === \"charset\" ? \"charset\" : \"content\";\n    },\n    resolveKeyData({ key }) {\n      return resolveMetaKeyValue(key);\n    },\n    resolveValueData({ value, key }) {\n      if (value === null)\n        return \"_null\";\n      if (typeof value === \"object\")\n        return resolvePackedMetaObjectValue(value, key);\n      return typeof value === \"number\" ? value.toString() : value;\n    }\n  });\n  return [...extras, ...meta].map((m) => {\n    if (m.content === \"_null\")\n      m.content = null;\n    return m;\n  });\n}\nfunction packMeta(inputs) {\n  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);\n  return packArray(inputs, {\n    key: [\"name\", \"property\", \"httpEquiv\", \"http-equiv\", \"charset\"],\n    value: [\"content\", \"charset\"],\n    resolveKey(k2) {\n      let key = mappedPackingSchema.filter((sk) => sk[1] === k2)?.[0]?.[0] || k2;\n      const replacer = (_, letter) => letter?.toUpperCase();\n      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);\n      return key;\n    }\n  });\n}\n\nconst WhitelistAttributes = {\n  htmlAttrs: [\"id\", \"class\", \"lang\", \"dir\"],\n  bodyAttrs: [\"id\", \"class\"],\n  meta: [\"id\", \"name\", \"property\", \"charset\", \"content\"],\n  noscript: [\"id\", \"textContent\"],\n  script: [\"id\", \"type\", \"textContent\"],\n  link: [\"id\", \"color\", \"crossorigin\", \"fetchpriority\", \"href\", \"hreflang\", \"imagesrcset\", \"imagesizes\", \"integrity\", \"media\", \"referrerpolicy\", \"rel\", \"sizes\", \"type\"]\n};\nfunction acceptDataAttrs(value) {\n  const filtered = {};\n  Object.keys(value || {}).filter((a) => a.startsWith(\"data-\")).forEach((a) => {\n    filtered[a] = value[a];\n  });\n  return filtered;\n}\nfunction whitelistSafeInput(input) {\n  const filtered = {};\n  Object.keys(input).forEach((key) => {\n    const tagValue = input[key];\n    if (!tagValue)\n      return;\n    switch (key) {\n      case \"title\":\n      case \"titleTemplate\":\n      case \"templateParams\":\n        filtered[key] = tagValue;\n        break;\n      case \"htmlAttrs\":\n      case \"bodyAttrs\":\n        filtered[key] = acceptDataAttrs(tagValue);\n        WhitelistAttributes[key].forEach((a) => {\n          if (tagValue[a])\n            filtered[key][a] = tagValue[a];\n        });\n        break;\n      case \"meta\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const safeMeta = acceptDataAttrs(meta);\n            WhitelistAttributes.meta.forEach((key2) => {\n              if (meta[key2])\n                safeMeta[key2] = meta[key2];\n            });\n            return safeMeta;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"link\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const link = acceptDataAttrs(meta);\n            WhitelistAttributes.link.forEach((key2) => {\n              const val = meta[key2];\n              if (key2 === \"rel\" && [\"stylesheet\", \"canonical\", \"modulepreload\", \"prerender\", \"preload\", \"prefetch\"].includes(val))\n                return;\n              if (key2 === \"href\") {\n                if (val.includes(\"javascript:\") || val.includes(\"data:\"))\n                  return;\n                link[key2] = val;\n              } else if (val) {\n                link[key2] = val;\n              }\n            });\n            return link;\n          }).filter((link) => Object.keys(link).length > 1 && !!link.rel);\n        }\n        break;\n      case \"noscript\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((meta) => {\n            const noscript = acceptDataAttrs(meta);\n            WhitelistAttributes.noscript.forEach((key2) => {\n              if (meta[key2])\n                noscript[key2] = meta[key2];\n            });\n            return noscript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n      case \"script\":\n        if (Array.isArray(tagValue)) {\n          filtered[key] = tagValue.map((script) => {\n            const safeScript = acceptDataAttrs(script);\n            WhitelistAttributes.script.forEach((s) => {\n              if (script[s]) {\n                if (s === \"textContent\") {\n                  try {\n                    const jsonVal = typeof script[s] === \"string\" ? JSON.parse(script[s]) : script[s];\n                    safeScript[s] = JSON.stringify(jsonVal, null, 0);\n                  } catch (e) {\n                  }\n                } else {\n                  safeScript[s] = script[s];\n                }\n              }\n            });\n            return safeScript;\n          }).filter((meta) => Object.keys(meta).length > 0);\n        }\n        break;\n    }\n  });\n  return filtered;\n}\n\nasync function normaliseTag(tagName, input, e) {\n  const tag = {\n    tag: tagName,\n    props: await normaliseProps(\n      // explicitly check for an object\n      // @ts-expect-error untyped\n      typeof input === \"object\" && typeof input !== \"function\" && !(input instanceof Promise) ? { ...input } : { [[\"script\", \"noscript\", \"style\"].includes(tagName) ? \"innerHTML\" : \"textContent\"]: input },\n      [\"templateParams\", \"titleTemplate\"].includes(tagName)\n    )\n  };\n  TagConfigKeys.forEach((k) => {\n    const val = typeof tag.props[k] !== \"undefined\" ? tag.props[k] : e[k];\n    if (typeof val !== \"undefined\") {\n      if (![\"innerHTML\", \"textContent\", \"children\"].includes(k) || TagsWithInnerContent.includes(tag.tag)) {\n        tag[k === \"children\" ? \"innerHTML\" : k] = val;\n      }\n      delete tag.props[k];\n    }\n  });\n  if (tag.props.body) {\n    tag.tagPosition = \"bodyClose\";\n    delete tag.props.body;\n  }\n  if (tag.tag === \"script\") {\n    if (typeof tag.innerHTML === \"object\") {\n      tag.innerHTML = JSON.stringify(tag.innerHTML);\n      tag.props.type = tag.props.type || \"application/json\";\n    }\n  }\n  return Array.isArray(tag.props.content) ? tag.props.content.map((v) => ({ ...tag, props: { ...tag.props, content: v } })) : tag;\n}\nfunction normaliseClassProp(v) {\n  if (typeof v === \"object\" && !Array.isArray(v)) {\n    v = Object.keys(v).filter((k) => v[k]);\n  }\n  return (Array.isArray(v) ? v.join(\" \") : v).split(\" \").filter((c) => c.trim()).filter(Boolean).join(\" \");\n}\nasync function normaliseProps(props, virtual) {\n  for (const k of Object.keys(props)) {\n    if (k === \"class\") {\n      props[k] = normaliseClassProp(props[k]);\n      continue;\n    }\n    if (props[k] instanceof Promise)\n      props[k] = await props[k];\n    if (!virtual && !TagConfigKeys.includes(k)) {\n      const v = String(props[k]);\n      const isDataKey = k.startsWith(\"data-\");\n      if (v === \"true\" || v === \"\") {\n        props[k] = isDataKey ? \"true\" : true;\n      } else if (!props[k]) {\n        if (isDataKey && v === \"false\")\n          props[k] = \"false\";\n        else\n          delete props[k];\n      }\n    }\n  }\n  return props;\n}\nconst TagEntityBits = 10;\nasync function normaliseEntryTags(e) {\n  const tagPromises = [];\n  Object.entries(e.resolvedInput).filter(([k, v]) => typeof v !== \"undefined\" && ValidHeadTags.includes(k)).forEach(([k, value]) => {\n    const v = asArray$1(value);\n    tagPromises.push(...v.map((props) => normaliseTag(k, props, e)).flat());\n  });\n  return (await Promise.all(tagPromises)).flat().filter(Boolean).map((t, i) => {\n    t._e = e._i;\n    e.mode && (t._m = e.mode);\n    t._p = (e._i << TagEntityBits) + i;\n    return t;\n  });\n}\n\nconst TAG_WEIGHTS = {\n  // tags\n  base: -10,\n  title: 10\n};\nconst TAG_ALIASES = {\n  // relative scores to their default values\n  critical: -80,\n  high: -10,\n  low: 20\n};\nfunction tagWeight(tag) {\n  let weight = 100;\n  const priority = tag.tagPriority;\n  if (typeof priority === \"number\")\n    return priority;\n  if (tag.tag === \"meta\") {\n    if (tag.props[\"http-equiv\"] === \"content-security-policy\")\n      weight = -30;\n    if (tag.props.charset)\n      weight = -20;\n    if (tag.props.name === \"viewport\")\n      weight = -15;\n  } else if (tag.tag === \"link\" && tag.props.rel === \"preconnect\") {\n    weight = 20;\n  } else if (tag.tag in TAG_WEIGHTS) {\n    weight = TAG_WEIGHTS[tag.tag];\n  }\n  if (typeof priority === \"string\" && priority in TAG_ALIASES) {\n    return weight + TAG_ALIASES[priority];\n  }\n  return weight;\n}\nconst SortModifiers = [{ prefix: \"before:\", offset: -1 }, { prefix: \"after:\", offset: 1 }];\n\nconst NetworkEvents = [\"onload\", \"onerror\", \"onabort\", \"onprogress\", \"onloadstart\"];\n\nconst sepSub = \"%separator\";\nfunction processTemplateParams(s, p, sep) {\n  if (typeof s !== \"string\" || !s.includes(\"%\"))\n    return s;\n  function sub(token) {\n    let val;\n    if ([\"s\", \"pageTitle\"].includes(token)) {\n      val = p.pageTitle;\n    } else if (token.includes(\".\")) {\n      val = token.split(\".\").reduce((acc, key) => acc ? acc[key] || void 0 : void 0, p);\n    } else {\n      val = p[token];\n    }\n    return typeof val !== \"undefined\" ? (val || \"\").replace(/\"/g, '\\\\\"') : false;\n  }\n  let decoded = s;\n  try {\n    decoded = decodeURI(s);\n  } catch {\n  }\n  const tokens = (decoded.match(/%(\\w+\\.+\\w+)|%(\\w+)/g) || []).sort().reverse();\n  tokens.forEach((token) => {\n    const re = sub(token.slice(1));\n    if (typeof re === \"string\") {\n      s = s.replace(new RegExp(`\\\\${token}(\\\\W|$)`, \"g\"), (_, args) => `${re}${args}`).trim();\n    }\n  });\n  if (s.includes(sepSub)) {\n    if (s.endsWith(sepSub))\n      s = s.slice(0, -sepSub.length).trim();\n    if (s.startsWith(sepSub))\n      s = s.slice(sepSub.length).trim();\n    s = s.replace(new RegExp(`\\\\${sepSub}\\\\s*\\\\${sepSub}`, \"g\"), sepSub);\n    s = processTemplateParams(s, { separator: sep }, sep);\n  }\n  return s;\n}\n\nexport { HasElementTags, IsBrowser, NetworkEvents, SelfClosingTags, SortModifiers, TAG_ALIASES, TAG_WEIGHTS, TagConfigKeys, TagEntityBits, TagsWithInnerContent, UniqueTags, ValidHeadTags, asArray$1 as asArray, composableNames, defineHeadPlugin, hashCode, hashTag, normaliseClassProp, normaliseEntryTags, normaliseProps, normaliseTag, packMeta, processTemplateParams, resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue, resolveTitleTemplate, tagDedupeKey, tagWeight, unpackMeta, whitelistSafeInput };\n","import { HasElementTags, hashTag, normaliseProps, tagDedupeKey, defineHeadPlugin } from '@unhead/shared';\n\nasync function elementToTag($el) {\n  const tag = {\n    tag: $el.tagName.toLowerCase(),\n    props: await normaliseProps(\n      $el.getAttributeNames().reduce((props, name) => ({ ...props, [name]: $el.getAttribute(name) }), {})\n    ),\n    innerHTML: $el.innerHTML\n  };\n  tag._d = tagDedupeKey(tag);\n  return tag;\n}\nasync function renderDOMHead(head, options = {}) {\n  const dom = options.document || head.resolvedOptions.document;\n  if (!dom)\n    return;\n  const beforeRenderCtx = { shouldRender: head.dirty, tags: [] };\n  await head.hooks.callHook(\"dom:beforeRender\", beforeRenderCtx);\n  if (!beforeRenderCtx.shouldRender)\n    return;\n  const tags = (await head.resolveTags()).map((tag) => ({\n    tag,\n    id: HasElementTags.includes(tag.tag) ? hashTag(tag) : tag.tag,\n    shouldRender: true\n  }));\n  let state = head._dom;\n  if (!state) {\n    state = {\n      elMap: { htmlAttrs: dom.documentElement, bodyAttrs: dom.body }\n    };\n    for (const key of [\"body\", \"head\"]) {\n      const children = dom?.[key]?.children;\n      for (const c of [...children].filter((c2) => HasElementTags.includes(c2.tagName.toLowerCase())))\n        state.elMap[c.getAttribute(\"data-hid\") || hashTag(await elementToTag(c))] = c;\n    }\n  }\n  state.pendingSideEffects = { ...state.sideEffects || {} };\n  state.sideEffects = {};\n  function track(id, scope, fn) {\n    const k = `${id}:${scope}`;\n    state.sideEffects[k] = fn;\n    delete state.pendingSideEffects[k];\n  }\n  function trackCtx({ id, $el, tag }) {\n    const isAttrTag = tag.tag.endsWith(\"Attrs\");\n    state.elMap[id] = $el;\n    if (!isAttrTag) {\n      [\"textContent\", \"innerHTML\"].forEach((k) => {\n        tag[k] && tag[k] !== $el[k] && ($el[k] = tag[k]);\n      });\n      track(id, \"el\", () => {\n        state.elMap[id].remove();\n        delete state.elMap[id];\n      });\n    }\n    Object.entries(tag.props).forEach(([k, value]) => {\n      const ck = `attr:${k}`;\n      if (k === \"class\") {\n        for (const c of (value || \"\").split(\" \").filter(Boolean)) {\n          isAttrTag && track(id, `${ck}:${c}`, () => $el.classList.remove(c));\n          !$el.classList.contains(c) && $el.classList.add(c);\n        }\n      } else {\n        $el.getAttribute(k) !== value && $el.setAttribute(k, value === true ? \"\" : String(value));\n        isAttrTag && track(id, ck, () => $el.removeAttribute(k));\n      }\n    });\n  }\n  const pending = [];\n  const frag = {\n    bodyClose: void 0,\n    bodyOpen: void 0,\n    head: void 0\n  };\n  for (const ctx of tags) {\n    const { tag, shouldRender, id } = ctx;\n    if (!shouldRender)\n      continue;\n    if (tag.tag === \"title\") {\n      dom.title = tag.textContent;\n      continue;\n    }\n    ctx.$el = ctx.$el || state.elMap[id];\n    if (ctx.$el)\n      trackCtx(ctx);\n    else\n      HasElementTags.includes(tag.tag) && pending.push(ctx);\n  }\n  for (const ctx of pending) {\n    const pos = ctx.tag.tagPosition || \"head\";\n    ctx.$el = dom.createElement(ctx.tag.tag);\n    trackCtx(ctx);\n    frag[pos] = frag[pos] || dom.createDocumentFragment();\n    frag[pos].appendChild(ctx.$el);\n  }\n  for (const ctx of tags)\n    await head.hooks.callHook(\"dom:renderTag\", ctx, dom, track);\n  frag.head && dom.head.appendChild(frag.head);\n  frag.bodyOpen && dom.body.insertBefore(frag.bodyOpen, dom.body.firstChild);\n  frag.bodyClose && dom.body.appendChild(frag.bodyClose);\n  Object.values(state.pendingSideEffects).forEach((fn) => fn());\n  head._dom = state;\n  head.dirty = false;\n  await head.hooks.callHook(\"dom:rendered\", { renders: tags });\n}\n\nasync function debouncedRenderDOMHead(head, options = {}) {\n  const fn = options.delayFn || ((fn2) => setTimeout(fn2, 10));\n  return head._domUpdatePromise = head._domUpdatePromise || new Promise((resolve) => fn(async () => {\n    await renderDOMHead(head, options);\n    delete head._domUpdatePromise;\n    resolve();\n  }));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction DomPlugin(options) {\n  return defineHeadPlugin((head) => {\n    const initialPayload = head.resolvedOptions.document?.head.querySelector('script[id=\"unhead:payload\"]')?.innerHTML || false;\n    initialPayload && head.push(JSON.parse(initialPayload));\n    return {\n      mode: \"client\",\n      hooks: {\n        \"entries:updated\": function(head2) {\n          debouncedRenderDOMHead(head2, options);\n        }\n      }\n    };\n  });\n}\n\nexport { DomPlugin, debouncedRenderDOMHead, renderDOMHead };\n","import { createHooks } from 'hookable';\nimport { DomPlugin } from '@unhead/dom';\nimport { defineHeadPlugin, tagDedupeKey, tagWeight, HasElementTags, hashCode, NetworkEvents, SortModifiers, processTemplateParams, resolveTitleTemplate, IsBrowser, normaliseEntryTags, composableNames, whitelistSafeInput, unpackMeta } from '@unhead/shared';\nexport { composableNames } from '@unhead/shared';\n\nconst UsesMergeStrategy = [\"templateParams\", \"htmlAttrs\", \"bodyAttrs\"];\nconst DedupePlugin = defineHeadPlugin({\n  hooks: {\n    \"tag:normalise\": function({ tag }) {\n      [\"hid\", \"vmid\", \"key\"].forEach((key) => {\n        if (tag.props[key]) {\n          tag.key = tag.props[key];\n          delete tag.props[key];\n        }\n      });\n      const generatedKey = tagDedupeKey(tag);\n      const dedupe = generatedKey || (tag.key ? `${tag.tag}:${tag.key}` : false);\n      if (dedupe)\n        tag._d = dedupe;\n    },\n    \"tags:resolve\": function(ctx) {\n      const deduping = {};\n      ctx.tags.forEach((tag) => {\n        const dedupeKey = (tag.key ? `${tag.tag}:${tag.key}` : tag._d) || tag._p;\n        const dupedTag = deduping[dedupeKey];\n        if (dupedTag) {\n          let strategy = tag?.tagDuplicateStrategy;\n          if (!strategy && UsesMergeStrategy.includes(tag.tag))\n            strategy = \"merge\";\n          if (strategy === \"merge\") {\n            const oldProps = dupedTag.props;\n            [\"class\", \"style\"].forEach((key) => {\n              if (oldProps[key]) {\n                if (tag.props[key]) {\n                  if (key === \"style\" && !oldProps[key].endsWith(\";\"))\n                    oldProps[key] += \";\";\n                  tag.props[key] = `${oldProps[key]} ${tag.props[key]}`;\n                } else {\n                  tag.props[key] = oldProps[key];\n                }\n              }\n            });\n            deduping[dedupeKey].props = {\n              ...oldProps,\n              ...tag.props\n            };\n            return;\n          } else if (tag._e === dupedTag._e) {\n            dupedTag._duped = dupedTag._duped || [];\n            tag._d = `${dupedTag._d}:${dupedTag._duped.length + 1}`;\n            dupedTag._duped.push(tag);\n            return;\n          } else if (tagWeight(tag) > tagWeight(dupedTag)) {\n            return;\n          }\n        }\n        const propCount = Object.keys(tag.props).length + (tag.innerHTML ? 1 : 0) + (tag.textContent ? 1 : 0);\n        if (HasElementTags.includes(tag.tag) && propCount === 0) {\n          delete deduping[dedupeKey];\n          return;\n        }\n        deduping[dedupeKey] = tag;\n      });\n      const newTags = [];\n      Object.values(deduping).forEach((tag) => {\n        const dupes = tag._duped;\n        delete tag._duped;\n        newTags.push(tag);\n        if (dupes)\n          newTags.push(...dupes);\n      });\n      ctx.tags = newTags;\n      ctx.tags = ctx.tags.filter((t) => !(t.tag === \"meta\" && (t.props.name || t.props.property) && !t.props.content));\n    }\n  }\n});\n\nconst PayloadPlugin = defineHeadPlugin({\n  mode: \"server\",\n  hooks: {\n    \"tags:resolve\": function(ctx) {\n      const payload = {};\n      ctx.tags.filter((tag) => [\"titleTemplate\", \"templateParams\", \"title\"].includes(tag.tag) && tag._m === \"server\").forEach((tag) => {\n        payload[tag.tag] = tag.tag.startsWith(\"title\") ? tag.textContent : tag.props;\n      });\n      Object.keys(payload).length && ctx.tags.push({\n        tag: \"script\",\n        innerHTML: JSON.stringify(payload),\n        props: { id: \"unhead:payload\", type: \"application/json\" }\n      });\n    }\n  }\n});\n\nconst ValidEventTags = [\"script\", \"link\", \"bodyAttrs\"];\nfunction stripEventHandlers(tag) {\n  const props = {};\n  const eventHandlers = {};\n  Object.entries(tag.props).forEach(([key, value]) => {\n    if (key.startsWith(\"on\") && typeof value === \"function\") {\n      if (NetworkEvents.includes(key))\n        props[key] = `this.dataset.${key} = true`;\n      eventHandlers[key] = value;\n    } else {\n      props[key] = value;\n    }\n  });\n  return { props, eventHandlers };\n}\nconst EventHandlersPlugin = defineHeadPlugin((head) => ({\n  hooks: {\n    \"tags:resolve\": function(ctx) {\n      for (const tag of ctx.tags) {\n        if (ValidEventTags.includes(tag.tag)) {\n          const { props, eventHandlers } = stripEventHandlers(tag);\n          tag.props = props;\n          if (Object.keys(eventHandlers).length) {\n            if (tag.props.src || tag.props.href)\n              tag.key = tag.key || hashCode(tag.props.src || tag.props.href);\n            tag._eventHandlers = eventHandlers;\n          }\n        }\n      }\n    },\n    \"dom:renderTag\": function(ctx, dom, track) {\n      if (!ctx.tag._eventHandlers)\n        return;\n      const $eventListenerTarget = ctx.tag.tag === \"bodyAttrs\" ? dom.defaultView : ctx.$el;\n      Object.entries(ctx.tag._eventHandlers).forEach(([k, value]) => {\n        const sdeKey = `${ctx.tag._d || ctx.tag._p}:${k}`;\n        const eventName = k.slice(2).toLowerCase();\n        const eventDedupeKey = `data-h-${eventName}`;\n        track(ctx.id, sdeKey, () => {\n        });\n        if (ctx.$el.hasAttribute(eventDedupeKey))\n          return;\n        ctx.$el.setAttribute(eventDedupeKey, \"\");\n        let observer;\n        const handler = (e) => {\n          value(e);\n          observer?.disconnect();\n        };\n        if (k in ctx.$el.dataset) {\n          handler(new Event(k.replace(\"on\", \"\")));\n        } else if (NetworkEvents.includes(k) && typeof MutationObserver !== \"undefined\") {\n          observer = new MutationObserver((e) => {\n            const hasAttr = e.some((m) => m.attributeName === `data-${k}`);\n            if (hasAttr) {\n              handler(new Event(k.replace(\"on\", \"\")));\n              observer?.disconnect();\n            }\n          });\n          observer.observe(ctx.$el, {\n            attributes: true\n          });\n        } else {\n          $eventListenerTarget.addEventListener(eventName, handler);\n        }\n        track(ctx.id, sdeKey, () => {\n          observer?.disconnect();\n          $eventListenerTarget.removeEventListener(eventName, handler);\n          ctx.$el.removeAttribute(eventDedupeKey);\n        });\n      });\n    }\n  }\n}));\n\nconst DupeableTags = [\"link\", \"style\", \"script\", \"noscript\"];\nconst HashKeyedPlugin = defineHeadPlugin({\n  hooks: {\n    \"tag:normalise\": ({ tag }) => {\n      if (tag.key && DupeableTags.includes(tag.tag)) {\n        tag.props[\"data-hid\"] = tag._h = hashCode(tag.key);\n      }\n    }\n  }\n});\n\nconst SortPlugin = defineHeadPlugin({\n  hooks: {\n    \"tags:resolve\": (ctx) => {\n      const tagPositionForKey = (key) => ctx.tags.find((tag) => tag._d === key)?._p;\n      for (const { prefix, offset } of SortModifiers) {\n        for (const tag of ctx.tags.filter((tag2) => typeof tag2.tagPriority === \"string\" && tag2.tagPriority.startsWith(prefix))) {\n          const position = tagPositionForKey(\n            tag.tagPriority.replace(prefix, \"\")\n          );\n          if (typeof position !== \"undefined\")\n            tag._p = position + offset;\n        }\n      }\n      ctx.tags.sort((a, b) => a._p - b._p).sort((a, b) => tagWeight(a) - tagWeight(b));\n    }\n  }\n});\n\nconst SupportedAttrs = {\n  meta: \"content\",\n  link: \"href\",\n  htmlAttrs: \"lang\"\n};\nconst TemplateParamsPlugin = defineHeadPlugin((head) => ({\n  hooks: {\n    \"tags:resolve\": (ctx) => {\n      const { tags } = ctx;\n      const title = tags.find((tag) => tag.tag === \"title\")?.textContent;\n      const idx = tags.findIndex((tag) => tag.tag === \"templateParams\");\n      const params = idx !== -1 ? tags[idx].props : {};\n      const sep = params.separator || \"|\";\n      delete params.separator;\n      params.pageTitle = processTemplateParams(params.pageTitle || title || \"\", params, sep);\n      for (const tag of tags.filter((t) => t.processTemplateParams !== false)) {\n        const v = SupportedAttrs[tag.tag];\n        if (v && typeof tag.props[v] === \"string\") {\n          tag.props[v] = processTemplateParams(tag.props[v], params, sep);\n        } else if (tag.processTemplateParams === true || [\"titleTemplate\", \"title\"].includes(tag.tag)) {\n          [\"innerHTML\", \"textContent\"].forEach((p) => {\n            if (typeof tag[p] === \"string\")\n              tag[p] = processTemplateParams(tag[p], params, sep);\n          });\n        }\n      }\n      head._templateParams = params;\n      head._separator = sep;\n      ctx.tags = tags.filter((tag) => tag.tag !== \"templateParams\");\n    }\n  }\n}));\n\nconst TitleTemplatePlugin = defineHeadPlugin({\n  hooks: {\n    \"tags:resolve\": (ctx) => {\n      const { tags } = ctx;\n      let titleTemplateIdx = tags.findIndex((i) => i.tag === \"titleTemplate\");\n      const titleIdx = tags.findIndex((i) => i.tag === \"title\");\n      if (titleIdx !== -1 && titleTemplateIdx !== -1) {\n        const newTitle = resolveTitleTemplate(\n          tags[titleTemplateIdx].textContent,\n          tags[titleIdx].textContent\n        );\n        if (newTitle !== null) {\n          tags[titleIdx].textContent = newTitle || tags[titleIdx].textContent;\n        } else {\n          delete tags[titleIdx];\n        }\n      } else if (titleTemplateIdx !== -1) {\n        const newTitle = resolveTitleTemplate(\n          tags[titleTemplateIdx].textContent\n        );\n        if (newTitle !== null) {\n          tags[titleTemplateIdx].textContent = newTitle;\n          tags[titleTemplateIdx].tag = \"title\";\n          titleTemplateIdx = -1;\n        }\n      }\n      if (titleTemplateIdx !== -1) {\n        delete tags[titleTemplateIdx];\n      }\n      ctx.tags = tags.filter(Boolean);\n    }\n  }\n});\n\nconst XSSPlugin = defineHeadPlugin({\n  hooks: {\n    \"tags:afterResolve\": function(ctx) {\n      for (const tag of ctx.tags) {\n        if (typeof tag.innerHTML === \"string\") {\n          if (tag.innerHTML && [\"application/ld+json\", \"application/json\"].includes(tag.props.type)) {\n            tag.innerHTML = tag.innerHTML.replace(/</g, \"\\\\u003C\");\n          } else {\n            tag.innerHTML = tag.innerHTML.replace(new RegExp(`</${tag.tag}`, \"g\"), `<\\\\/${tag.tag}`);\n          }\n        }\n      }\n    }\n  }\n});\n\nlet activeHead;\n// @__NO_SIDE_EFFECTS__\nfunction createHead(options = {}) {\n  const head = createHeadCore(options);\n  head.use(DomPlugin());\n  return activeHead = head;\n}\n// @__NO_SIDE_EFFECTS__\nfunction createServerHead(options = {}) {\n  return activeHead = createHeadCore(options);\n}\nfunction filterMode(mode, ssr) {\n  return !mode || mode === \"server\" && ssr || mode === \"client\" && !ssr;\n}\nfunction createHeadCore(options = {}) {\n  const hooks = createHooks();\n  hooks.addHooks(options.hooks || {});\n  options.document = options.document || (IsBrowser ? document : void 0);\n  const ssr = !options.document;\n  const updated = () => {\n    head.dirty = true;\n    hooks.callHook(\"entries:updated\", head);\n  };\n  let entryCount = 0;\n  let entries = [];\n  const plugins = [];\n  const head = {\n    plugins,\n    dirty: false,\n    resolvedOptions: options,\n    hooks,\n    headEntries() {\n      return entries;\n    },\n    use(p) {\n      const plugin = typeof p === \"function\" ? p(head) : p;\n      if (!plugin.key || !plugins.some((p2) => p2.key === plugin.key)) {\n        plugins.push(plugin);\n        filterMode(plugin.mode, ssr) && hooks.addHooks(plugin.hooks || {});\n      }\n    },\n    push(input, entryOptions) {\n      delete entryOptions?.head;\n      const entry = {\n        _i: entryCount++,\n        input,\n        ...entryOptions\n      };\n      if (filterMode(entry.mode, ssr)) {\n        entries.push(entry);\n        updated();\n      }\n      return {\n        dispose() {\n          entries = entries.filter((e) => e._i !== entry._i);\n          hooks.callHook(\"entries:updated\", head);\n          updated();\n        },\n        // a patch is the same as creating a new entry, just a nice DX\n        patch(input2) {\n          entries = entries.map((e) => {\n            if (e._i === entry._i) {\n              e.input = entry.input = input2;\n            }\n            return e;\n          });\n          updated();\n        }\n      };\n    },\n    async resolveTags() {\n      const resolveCtx = { tags: [], entries: [...entries] };\n      await hooks.callHook(\"entries:resolve\", resolveCtx);\n      for (const entry of resolveCtx.entries) {\n        const resolved = entry.resolvedInput || entry.input;\n        entry.resolvedInput = await (entry.transform ? entry.transform(resolved) : resolved);\n        if (entry.resolvedInput) {\n          for (const tag of await normaliseEntryTags(entry)) {\n            const tagCtx = { tag, entry, resolvedOptions: head.resolvedOptions };\n            await hooks.callHook(\"tag:normalise\", tagCtx);\n            resolveCtx.tags.push(tagCtx.tag);\n          }\n        }\n      }\n      await hooks.callHook(\"tags:beforeResolve\", resolveCtx);\n      await hooks.callHook(\"tags:resolve\", resolveCtx);\n      await hooks.callHook(\"tags:afterResolve\", resolveCtx);\n      return resolveCtx.tags;\n    },\n    ssr\n  };\n  [\n    DedupePlugin,\n    PayloadPlugin,\n    EventHandlersPlugin,\n    HashKeyedPlugin,\n    SortPlugin,\n    TemplateParamsPlugin,\n    TitleTemplatePlugin,\n    XSSPlugin,\n    ...options?.plugins || []\n  ].forEach((p) => head.use(p));\n  head.hooks.callHook(\"init\", head);\n  return head;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction HashHydrationPlugin() {\n  return defineHeadPlugin({});\n}\n\nconst importRe = /@import/;\n// @__NO_SIDE_EFFECTS__\nfunction CapoPlugin(options) {\n  return defineHeadPlugin({\n    hooks: {\n      \"tags:beforeResolve\": function({ tags }) {\n        for (const tag of tags) {\n          if (tag.tagPosition && tag.tagPosition !== \"head\")\n            continue;\n          tag.tagPriority = tag.tagPriority || tagWeight(tag);\n          if (tag.tagPriority !== 100)\n            continue;\n          const isTruthy = (val) => val === \"\" || val === true;\n          const isScript = tag.tag === \"script\";\n          const isLink = tag.tag === \"link\";\n          if (isScript && isTruthy(tag.props.async)) {\n            tag.tagPriority = 30;\n          } else if (tag.tag === \"style\" && tag.innerHTML && importRe.test(tag.innerHTML)) {\n            tag.tagPriority = 40;\n          } else if (isScript && tag.props.src && !isTruthy(tag.props.defer) && !isTruthy(tag.props.async) && tag.props.type !== \"module\" && !tag.props.type?.endsWith(\"json\")) {\n            tag.tagPriority = 50;\n          } else if (isLink && tag.props.rel === \"stylesheet\" || tag.tag === \"style\") {\n            tag.tagPriority = 60;\n          } else if (isLink && [\"preload\", \"modulepreload\"].includes(tag.props.rel)) {\n            tag.tagPriority = 70;\n          } else if (isScript && isTruthy(tag.props.defer) && tag.props.src && !isTruthy(tag.props.async)) {\n            tag.tagPriority = 80;\n          } else if (isLink && [\"prefetch\", \"dns-prefetch\", \"prerender\"].includes(tag.props.rel)) {\n            tag.tagPriority = 90;\n          }\n        }\n        options?.track && tags.push({\n          tag: \"htmlAttrs\",\n          props: {\n            \"data-capo\": \"\"\n          }\n        });\n      }\n    }\n  });\n}\n\nconst unheadComposablesImports = [\n  {\n    from: \"unhead\",\n    imports: composableNames\n  }\n];\n\nfunction getActiveHead() {\n  return activeHead;\n}\n\nfunction useHead(input, options = {}) {\n  const head = options.head || getActiveHead();\n  return head?.push(input, options);\n}\n\nfunction useHeadSafe(input, options = {}) {\n  return useHead(input, {\n    ...options || {},\n    transform: whitelistSafeInput\n  });\n}\n\nfunction useServerHead(input, options = {}) {\n  return useHead(input, { ...options, mode: \"server\" });\n}\n\nfunction useServerHeadSafe(input, options = {}) {\n  return useHeadSafe(input, { ...options, mode: \"server\" });\n}\n\nfunction useSeoMeta(input, options) {\n  const { title, titleTemplate, ...meta } = input;\n  return useHead({\n    title,\n    titleTemplate,\n    // we need to input the meta so the reactivity will be resolved\n    // @ts-expect-error runtime type\n    _flatMeta: meta\n  }, {\n    ...options,\n    transform(t) {\n      const meta2 = unpackMeta({ ...t._flatMeta });\n      delete t._flatMeta;\n      return {\n        // @ts-expect-error runtime type\n        ...t,\n        meta: meta2\n      };\n    }\n  });\n}\n\nfunction useServerSeoMeta(input, options) {\n  return useSeoMeta(input, {\n    ...options || {},\n    mode: \"server\"\n  });\n}\n\nconst UseScriptDefaults = {\n  defer: true,\n  fetchpriority: \"low\"\n};\nfunction useScript(input, _options) {\n  const options = _options || {};\n  const head = options.head || getActiveHead();\n  if (!head)\n    throw new Error(\"No active head found, please provide a head instance or use the useHead composable\");\n  const id = input.key || hashCode(input.src || (typeof input.innerHTML === \"string\" ? input.innerHTML : \"\"));\n  const key = `use-script.${id}`;\n  if (head._scripts?.[id])\n    return head._scripts[id];\n  async function transform(entry) {\n    const script2 = await (options.transform || ((input2) => input2))(entry.script[0]);\n    const ctx = { script: script2 };\n    await head.hooks.callHook(\"script:transform\", ctx);\n    return { script: [ctx.script] };\n  }\n  function maybeHintEarlyConnection(rel) {\n    if (\n      // opt-out\n      options.skipEarlyConnections || !input.src.includes(\"//\") || !head.ssr\n    )\n      return;\n    const key2 = `use-script.${id}.early-connection`;\n    head.push({\n      link: [{ key: key2, rel, href: new URL(input.src).origin }]\n    }, { mode: \"server\" });\n  }\n  const script = {\n    id,\n    status: \"awaitingLoad\",\n    loaded: false,\n    remove() {\n      if (script.status === \"loaded\") {\n        script.entry?.dispose();\n        script.status = \"removed\";\n        head.hooks.callHook(`script:updated`, hookCtx);\n        delete head._scripts?.[id];\n        return true;\n      }\n      return false;\n    },\n    waitForLoad() {\n      return new Promise((resolve) => {\n        if (script.status === \"loaded\")\n          resolve(options.use());\n        function watchForScriptLoaded({ script: script2 }) {\n          if (script2.id === id && script2.status === \"loaded\") {\n            resolve(options.use?.());\n            head.hooks.removeHook(\"script:updated\", watchForScriptLoaded);\n          }\n        }\n        head.hooks.hook(\"script:updated\", watchForScriptLoaded);\n      });\n    },\n    load() {\n      if (script.status !== \"awaitingLoad\")\n        return script.waitForLoad();\n      script.status = \"loading\";\n      head.hooks.callHook(`script:updated`, hookCtx);\n      script.entry = head.push({\n        script: [\n          // async by default\n          { ...UseScriptDefaults, ...input, key }\n        ]\n      }, {\n        ...options,\n        // @ts-expect-error untyped\n        transform,\n        head\n      });\n      return script.waitForLoad();\n    }\n  };\n  const hookCtx = { script };\n  NetworkEvents.forEach((fn) => {\n    const _fn = typeof input[fn] === \"function\" ? input[fn].bind({}) : null;\n    input[fn] = (e) => {\n      script.status = fn === \"onload\" ? \"loaded\" : fn === \"onerror\" ? \"error\" : \"loading\";\n      head.hooks.callHook(`script:updated`, hookCtx);\n      _fn && _fn(e);\n    };\n  });\n  let trigger = options.trigger;\n  if (trigger) {\n    const isIdle = trigger === \"idle\";\n    if (isIdle) {\n      if (head.ssr)\n        trigger = \"manual\";\n      else\n        trigger = new Promise((resolve) => requestIdleCallback(() => resolve()));\n    }\n    trigger === \"manual\" && (trigger = new Promise(() => {\n    }));\n    trigger instanceof Promise && trigger.then(script.load);\n    maybeHintEarlyConnection(isIdle ? \"preconnect\" : \"dns-prefetch\");\n  } else {\n    script.load();\n    maybeHintEarlyConnection(\"preconnect\");\n  }\n  function resolveInnerHtmlLoad(ctx) {\n    if (ctx.tag.key === key) {\n      if (ctx.tag.innerHTML) {\n        setTimeout(\n          () => {\n            script.status = \"loaded\";\n            head.hooks.callHook(\"script:updated\", hookCtx);\n            typeof input.onload === \"function\" && input.onload(new Event(\"load\"));\n          },\n          5\n          /* give inline script a chance to run */\n        );\n      }\n      head.hooks.removeHook(\"dom:renderTag\", resolveInnerHtmlLoad);\n    }\n  }\n  head.hooks.hook(\"dom:renderTag\", resolveInnerHtmlLoad);\n  const instance = new Proxy({}, {\n    get(_, fn) {\n      const stub = options.stub?.({ script, fn });\n      if (stub)\n        return stub;\n      if (fn === \"$script\")\n        return script;\n      return (...args) => {\n        if (head.ssr || !options.use)\n          return;\n        if (script.loaded) {\n          const api = options.use();\n          return api[fn](...args);\n        } else {\n          return script.waitForLoad().then(\n            (api) => {\n              api[fn](...args);\n            }\n          );\n        }\n      };\n    }\n  });\n  head._scripts = head._scripts || {};\n  head._scripts[id] = instance;\n  return instance;\n}\n\nexport { CapoPlugin, HashHydrationPlugin, createHead, createHeadCore, createServerHead, getActiveHead, unheadComposablesImports, useHead, useHeadSafe, useScript, useSeoMeta, useServerHead, useServerHeadSafe, useServerSeoMeta };\n","import { version, unref, nextTick, inject } from 'vue';\nimport { createServerHead as createServerHead$1, createHead as createHead$1, getActiveHead } from 'unhead';\nimport { defineHeadPlugin } from '@unhead/shared';\n\nconst Vue3 = version.startsWith(\"3\");\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref, lastKey = \"\") {\n  if (ref instanceof Promise)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r, lastKey));\n  if (typeof root === \"object\") {\n    return Object.fromEntries(\n      Object.entries(root).map(([k, v]) => {\n        if (k === \"titleTemplate\" || k.startsWith(\"on\"))\n          return [k, unref(v)];\n        return [k, resolveUnrefHeadInput(v, k)];\n      })\n    );\n  }\n  return root;\n}\n\nconst VueReactivityPlugin = defineHeadPlugin({\n  hooks: {\n    \"entries:resolve\": function(ctx) {\n      for (const entry of ctx.entries)\n        entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n    }\n  }\n});\n\nconst headSymbol = \"usehead\";\nfunction vueInstall(head) {\n  const plugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.config.globalProperties.$head = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  return plugin.install;\n}\nfunction createServerHead(options = {}) {\n  const head = createServerHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\nfunction createHead(options = {}) {\n  options.domDelayFn = options.domDelayFn || ((fn) => nextTick(() => setTimeout(() => fn(), 0)));\n  const head = createHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__unhead_injection_handler__\";\nfunction setHeadInjectionHandler(handler) {\n  _global[globalKey] = handler;\n}\nfunction injectHead() {\n  if (globalKey in _global) {\n    return _global[globalKey]();\n  }\n  const head = inject(headSymbol);\n  if (!head && process.env.NODE_ENV !== \"production\")\n    console.warn(\"Unhead is missing Vue context, falling back to shared context. This may have unexpected results.\");\n  return head || getActiveHead();\n}\n\nexport { Vue3 as V, createServerHead as a, createHead as c, headSymbol as h, injectHead as i, resolveUnrefHeadInput as r, setHeadInjectionHandler as s };\n"],"names":["asArray$1","value","TagsWithInnerContent","HasElementTags","ValidHeadTags","UniqueTags","TagConfigKeys","IsBrowser","hashCode","s","h","i","hashTag","tag","key","tagDedupeKey","fn","props","tagName","name","n","val","resolveTitleTemplate","template","title","normaliseTag","input","e","normaliseProps","k","v","normaliseClassProp","c","virtual","isDataKey","TagEntityBits","normaliseEntryTags","tagPromises","TAG_WEIGHTS","TAG_ALIASES","tagWeight","weight","priority","SortModifiers","NetworkEvents","sepSub","processTemplateParams","p","sep","sub","token","acc","decoded","re","_","args","elementToTag","$el","renderDOMHead","head","options","dom","beforeRenderCtx","tags","state","children","_a","c2","track","id","scope","trackCtx","isAttrTag","ck","pending","frag","ctx","shouldRender","pos","debouncedRenderDOMHead","fn2","resolve","DomPlugin","initialPayload","_b","head2","UsesMergeStrategy","DedupePlugin","dedupe","deduping","dedupeKey","dupedTag","strategy","oldProps","propCount","newTags","dupes","t","PayloadPlugin","payload","ValidEventTags","stripEventHandlers","eventHandlers","EventHandlersPlugin","$eventListenerTarget","sdeKey","eventName","eventDedupeKey","observer","handler","m","DupeableTags","HashKeyedPlugin","SortPlugin","tagPositionForKey","prefix","offset","tag2","position","a","b","SupportedAttrs","TemplateParamsPlugin","idx","params","TitleTemplatePlugin","titleTemplateIdx","titleIdx","newTitle","XSSPlugin","activeHead","createHead","createHeadCore","filterMode","mode","ssr","hooks","createHooks","updated","entryCount","entries","plugins","plugin","p2","entryOptions","entry","input2","resolveCtx","resolved","tagCtx","getActiveHead","Vue3","version","resolveUnref","r","unref","resolveUnrefHeadInput","ref","lastKey","root","VueReactivityPlugin","headSymbol","vueInstall","app","nextTick","createHead$1","_global","globalKey","setHeadInjectionHandler","injectHead","inject"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}